[preface]
== Prefacio

image::jrmora/00-prefacio.jpg[align="center"]


Hace más de veinte años que enseño _concurrencia_ en las asignaturas de _Sistemas Operativos I_ y _II_ y en  _Programación Concurrente y Distribuida_ de la carrera de informática en la Universitat de les Illes Balears. A pesar de la cantidad de notas y presentaciones que elaboré en todos estos años, nunca se me pasó por la cabeza escribir un libro. Ni siquiera el típico libro de apoyo a la asignatura. Es sumamente complicado transmitir las sutilezas y conflictos generados por ejecuciones que no cumplen con la _secuencialidad_ de sus programas. Si ya me resultaba difícil en clases magistrales y prácticas en laboratorio, me parecía tarea imposible escribir un libro.

Pero eso cambió en diciembre de 2014.

=== Motivación
Un amigo programador que no estudió informática se encontró con un problema de _estructuras concurrentes_. Quería aprender más sobre el tema y me preguntó en Twitter qué bibliografía le recomendaba, me metió en un problema.

Hay muy buenos libros de texto sobre concurrencia, pero además de ser caros -en general superan los 60 €- están muy orientados a la parte formal del problema, no a las aplicaciones prácticas. También suelen usar lenguajes y formalismos poco usados (Promela, Concurrent Pascal, BACI, ADA) que no tienen sentido para un programador que quiere aprender o actualizarse y poder transferir rápidamente esos conocimientos a su lenguaje preferido.

Hay buenos libros orientados a divulgación y actualización (como <<Herlihy12>>), pero además de caros están especializados en pocos temas y orientados a una audiencia más académica. También hay buenos libros escritos para un lenguaje en particular y sus herramientas, pero no explican los orígenes y principios fundamentales de concurrencia.

Mientras revisaba bibliografía, mi amigo buscó apuntes y notas de clase de las universidades más prestigiosas y preguntaba mi opinión. Estaban bien, pero la mayoría fueron escritos más como soporte de clases que como textos estructurados y autónomos.

No hice un extenso análisis de mercado, no obstante, en pocas horas me di cuenta que me resultaba imposible recomendar un libro. No encontraba uno que explicase concurrencia de la forma que yo consideraba adecuada para un programador interesado en aprender sus fundamentos desde cero.

Casi como una broma respondí ''a ver si tengo que escribirlo en un ebook'', lo que generó inmediatas peticiones para que lo hiciese.

Así es como surgió este libro, no sabía en lo que me metía. Pensé que lo podría hacer en tres meses con menos de 20 000 palabras, pero acabó teniendo más de 55 000 además de las 22 000 líneas de código en cinco lenguajes diferentes escritos exclusivamente para este libro.

Creo que en el libro logro explicar, con ejemplos en lenguajes modernos y populares, lo que considero fundamental de los principios y algoritmos claves de concurrencia. Es una opinión subjetiva, cada lector tendrá su opinión y quejas de por qué no incluí esa característica tan especial de su lenguaje preferido. Es muy difícil refutar, se necesitaría un ensayo filosófico y seguiría siendo discutible. Pero cuento con la ventaja de haber enseñado estos temas durante dos décadas. No solo sé lo que me ha costado dominar ciertos temas, también lo que cuesta transmitir y hacer _captar_ las sutilezas de la programación concurrente.

No se trata de aprender de memoria unos algoritmos, ni de saber exactamente cómo y cuándo usarlos. Se trata de otra forma de pensar la programación. Los programas ya no son una secuencia de instrucciones, se ha de razonar de forma diferente. No se trata de solo _este programa_, sino de cómo puede interactuar con _otros_; y cómo afecta la ejecución de esos _otros_ a los resultados de _éste_. Hay que razonar de forma _no lineal_ y _concurrente_, no se adquiere con una asignatura ni leyendo un libro durante un fin de semana. Requiere motivación y entrenamiento, pero no cabe duda de la utilidad de un libro que explique los fundamentos y los acompañe con código de demostración.

Tuve la sensación que no había un libro de ese tipo, al menos no para el público objetivo: el programador que no tuvo la suerte de una formación universitaria; que quiere actualizarse; o que sencillamente se olvidó de lo que estudió en esa oscura asignatura de hace años y hoy tiene las ganas o la necesidad de recordarlo.

Ante esta situación, y dado que el tiempo para escribir un libro es finito, estuve obligado filtrar y seleccionar lo fundamental, separar los principios de lo que son derivaciones o metaconstrucciones sobre esos pilares básicos. Hice el esfuerzo, no sé si están todos los que son pero sí sé que los que están son fundamentales.

=== Escribir un _eBook_ técnico legible
Este libro tiene muchos algoritmos y programas completos, mis experiencias con libros electrónicos de este tipo no son las mejores. La mayoría incluyen ejemplos de programas -con tratamientos de excepciones incluidas- cuyas líneas no alcanzan a mostrarse completas en la pequeña pantalla del lector. Me duele la cabeza de solo recordarlo, hay que hacer un gran esfuerzo para descifrar la parte importante del algoritmo.

Al momento de escribir estas líneas no sé si habrá una versión impresa del libro, no contacté con ninguna editorial, la intención desde el principio fue hacer un _ebook_ que fuese accesible, compacto y con ejemplos razonablemente fáciles de leer. No fue tarea sencilla pero fui muy cuidadoso en estos aspectos, creo que el resultado es bueno. En vez de inventar otro pseudocódigo usé directamente Python, no solo es expresivo, es fácil de comprender y los programas además son válidos.

Por esa claridad y expresividad muchos ejemplos están escritos en Python, pero solo si era el más adecuado para mostrar el funcionamiento y los problemas tratados. Los programas completos están en cinco lenguajes diferentes (C, Python, Java, Go y ensamblador de ARM), usé siempre el que me parece el más apropiado para demostrar lo que estaba explicando. En algunos casos traduje el código a Python para explicarlo en el texto, en otros casos usé el lenguaje original pero simplifiqué el código quitando lo accesorio (como largas listas de argumentos, tratamiento de excepciones y nombres extensos).

De todas formas, me parece importante -es lo que espero de un libro electrónico- poder analizar el código completo. Dado que un _eBook_ no tiene las restricciones de un libro físico, decidí que todos los programas debían estar disponibles directamente desde el lector sin necesidad de conectarse a internet ni escribir URLs en un ordenador. El listado completo de todos los programas <<source_code, están en los apéndices>> al final del libro (aproximadamente el 30% del total de contenido del libro), cada uno de ellos está enlazado desde el texto donde se discute el código simplificado. Ya en el apéndice, justo antes del código, está el enlace al original en https://github.com/gallir/concurrencia_source_samples[Github].

Creo que en este aspecto cumplí los objetivos, los algoritmos en el texto son legibles -aún en pantallas de teléfonos-, van directo a la parte que interesa y no necesitan tres pantallas. Pero con un _clic_ se puede ver el programa completo sin salir del libro, con otro _clic_ se puede acceder al repositorio para bajarlo a un ordenador.


=== Sobre el contenido
Intenté que este libro sea compacto e ir directamente al grano sin demasiadas analogías,  como es habitual en los libros de texto. A pesar del esfuerzo deliberado por la brevedad la longitud final es equivalente a más de 200 páginas -descontando el listado de los programas- de un libro impreso. Cada párrafo suele describir completamente una idea o concepto, cada oración es un avance hacia ese objetivo.

La lectura puede dar la sensación de agobio por la rapidez con que se avanza, también me pasaba durante las revisiones y correcciones. Pido disculpas por no saber hacerlo mejor, pero en cierta forma es inevitable si se escribe un texto donde se introducen tantos temas complejos.

En mi defensa debo decir que vivimos en una época donde el conocimiento está al alcance de unos pocos clics, hay material accesible para los interesados en profundizar algún tema. Para facilitar la búsqueda fui cuidadoso con la bibliografía, aunque intenté referenciar a los artículos científicos originales también me tomé el trabajo de buscarlos en internet (en algunos casos me costó encontrar artículos de los años 60 y 70) y añadir el enlace.

==== Conocimientos previos requeridos
No se requieren ni se suponen conocimientos de concurrencia. Solo se requieren conocimientos de programación, estructuras de datos básicas (pilas, colas, listas) y comprender lo que es un puntero o referencia a memoria.

El texto comienza desde los conceptos más básicos y avanza gradual e incrementalmente, cada párrafo o algoritmo es un avance sobre lo visto previamente. No hay conceptos importantes que no se expliquen al menos brevemente. Quizás encuentres algunos que no conoces, si no los expliqué es porque son muy fáciles de encontrar, sobre todo en la Wikipedia.

Los programas están desarrollados y probados en GNU/Linux. Para ejecutarlos y probarlos se necesita acceso a un ordenador con este sistema. No hace falta ser un experto pero sí tener un mínimo de experiencia con comandos básicos de consola.


==== Los programas
Uno de los requisitos que me impuse fue que todo lo que explicase debía ir acompañado de programas que compilen y funcionen correctamente. Además de estar listados en los apéndices se pueden bajar desde Github con un comando. Son libres, puedes hacer con ellos lo que desees.

Otro requisito autoimpuesto, todos los programas deberían poder ser compilados y ejecutados en el ordenador más básico posible, cualquier Raspberry con sus distribuciones estándares de GNU/Linux. Están preparados para que funcionen con cualquier distribución relativamente moderna y probados sobre Raspberry 1 y 2 con Debian Jessie y Ubuntu 14.04. Para compilarlos hay que instalar los paquetes del gcc, Golang, Python y el SDK de Java -todos disponibles en cualquier distribución- y ejecutar el comando +make+ en cada uno de los directorios (organizados por capítulos).

La regla para usar uno u otro lenguaje de programación fue elegir el más apto para el tema en cuestión, si era una buena opción usaba Python. Para _monitores_ usé principalmente Java porque es un lenguaje popular que incluye a los monitores como construcción sintáctica del lenguaje. Para _canales_ usé Go por la misma razón, son una construcción del lenguaje.

Hay bastantes ejemplos en C, lo usé cuando no había opción de hacerlo en otro lenguaje o porque éste era el más adecuado para ese caso. Mi opinión es que los programadores deben saber C, su gramática es muy sencilla y a la vez está muy próximo a la arquitectura. Si no se conoce ensamblador es la mejor forma de tener una idea de las transformaciones que deben hacer los intérpretes y máquinas virtuales (la mayoría de ellas programadas en C o C++) para pasar de abstracciones de alto nivel a código ejecutable por el procesador. En general es notable la diferencia de calidad de código de los programadores que conocen lo que ocurre tras las bambalinas de la máquina virtual respecto a los que lo ignoran completamente. Si no sabes C no te preocupes, los programas son breves, se usan siempre las mismas funciones y están explicados -a veces línea a línea-.

Usé ensamblador en un <<stack_llsc_freelist_s, único caso>>, no había otra opción para demostrar el funcionamiento de las instrucciones de sincronización _LL/SC_. Afortunadamente los procesadores ARM de ambos modelos de Raspberry (ARMv6 y ARMv7) soportan esas instrucciones, no hace falta hardware especial o caro.

En algunos algoritmos hay ejemplos en varios lenguajes diferentes, me pareció oportuno mostrar cómo se hacen en cada uno de ellos, o cómo se pueden construir mecanismos similares (notablemente simular monitores en C y Python). Para los que conozcan un lenguaje mejor que otro puede ser clarificador. De todas maneras nunca está mal acostumbrarse a interpretar algoritmos en varios lenguajes, es la mejor forma de perder el miedo a aprender lenguajes.

==== Terminología
Escribí el libro en castellano porque pensé que sería mucho más sencillo que hacerlo en inglés, ahora pienso que quizás me complicó más. Cuando se trata de bibliografía técnica intento leer siempre el original en inglés, por lo que no domino la terminología específica en castellano. He tenido que dedicar mucho tiempo a encontrar las traducciones adecuadas para los nombres técnicos, espero haber hecho un buen trabajo. Aunque me negué a traducir algunas palabras que son parte de nuestro vocabulario habitual como _array_, _buffer_, _spinlock_ o _scheduler_.

Una parte importante del aprendizaje y entrenamiento de cualquier área de conocimiento es conocer la terminología técnica, ésta permite la discusión y transmisión del conocimiento de forma más compacta y sin ambigüedades. Para bien o para mal, la lengua vehicular de la informática es el inglés, es importante conocer también la terminología técnica en ese idioma. En este aspecto fui cuidadoso de indicar su equivalente en inglés cada vez que introduzco un concepto o definición nueva.

Tampoco es fácil seleccionar una definición en particular, muchas veces doy varios sinónimos -en castellano y en inglés- porque no hay un consenso universal ni en la comunidad científica. Algunos términos se usan más en un entorno (como _lock-free_ y _critical section_) y en otros se refieren a lo mismo con palabras diferentes (_deadlock-free_ y _mutual exclusion_ respectivamente), en estos casos inicialmente describo ambos términos (en inglés y castellano) y los uso indistintamente.

==== Para docencia
No fue la intención original pero este libro cubre completamente, y con algo más, los contenidos de concurrencia que se suelen dar en las carreras de informática. Hace unos años estos temas eran una parte de las asignaturas de sistemas operativos. Fue en esta área donde primero aparecieron los problemas de concurrencia, era natural que se explicasen en estas asignaturas. Pero el área de concurrencia se amplió y profundizó, ya tiene peso e importancia por sí mismafootnote:[Algunos consideramos que es clave en la formación, forma parte de los principios fundamentales de la informática.] por lo que ya existen asignaturas específicas de programación concurrente. Este libro cubre todos los temas de concurrencia que se dan en esas asignaturas y que sería el equivalente a aproximadamente un semestre.

Una de las carencias más importantes en la docencia de concurrencia es que no se suele enseñar temas que avanzaron mucho en los últimos años, como el diseño de algoritmos de _spinlocks_ con instrucciones de hardware, o las interfaces de los sistemas operativos para la programación de primitivas de sincronización como _FUTEX_. Es razonable esa carencia, el tiempo es finito y no suelen estar incluidos en los libros de texto de sistemas operativos ni de programación concurrente. Creo que los dos temas mencionados son complejos pero importantes, por eso dediqué un capítulo a cada uno de ellos con ejemplos de las técnicas y algoritmos más usados.


==== Capítulos

<<processes_concurrency>>:: Es la introducción a concurrencia, procesos e hilos y cómo son gestionados y planificados por el sistema operativo. Describe el problema del intercalado y cómo es el responsable de los problemas de concurrencia. Me parece que es un capítulo sencillo de entender y de lectura fácil pero importante, define con precisión qué es la programación concurrente.

<<mutual_exclusion>>:: Describe las soluciones por software al problema fundamental de concurrencia, la exclusión mutua. Comienza con los casos más sencillos para dos procesos hasta acabar en soluciones genéricas. Su objetivo también es enseñar cómo se razonan, diseñan y evalúan los programas concurrentes. Si tienes experiencia con programación concurrente y conocen el algoritmo de la panadería podrías saltarte este capítulo, pero si no tienes experiencia o no recuerdas los requisitos y sus razones es de lectura obligada.

<<barriers>>:: Las soluciones por software no funcionan si no se tiene en cuenta la evolución y funcionamiento de los procesadores modernos, arquitecturas de multiprocesamiento y modelos de coherencia de la memoria caché. De lectura obligada si no sabes por qué los procesadores no aseguran la consistencia secuencial, o qué son las barreras de memoria.

<<hardware>>:: Se describen las instrucciones de hardware diseñadas para facilitar la sincronización de procesos, cómo usarlas para solucionar la exclusión mutua con _spinlocks_ básicos, los problemas _ocultos_ y sus soluciones. Salvo la última parte donde se discute y soluciona el _problema ABA_ no me parece un capítulo muy complejo pero sí muy pedagógico del porqué y cómo se diseñan y usan las operaciones atómicas de los procesadores.

<<spinlocks>>:: Es el capítulo más extenso y quizás el más complejo, trata temas que habitualmente no aparecen en los libros de texto (quizás por la complejidad). Avanza en el tema de _spinlock_, explica cómo hacer más eficientes los _spinlocks_ simples y los algoritmos más complejos desarrollados recientemente. Es de lectura obligada para los que pretenden convertirse en programadores de sistemas operativos, de sistemas empotrados, o de los que tienen que trabajar con estructuras concurrentes (muy usadas en bases de datos, máquinas virtuales o intérpretes de lenguajes).

<<semaphores>>:: Con éste comienza una segunda parte bien diferenciada. En los capítulos previos se tratan algoritmos con espera activa, a partir de éste se estudian las soluciones para evitar esas esperas activas haciendo que los procesos se bloqueen cuando no deben continuar. La construcción de semáforos fue la primera en este sentido, la inventó Dijkstra a finales de la década de 1960 y es sin duda un pilar fundamental de todas las construcciones posteriores para sincronización de procesos. No me parece un capítulo complejo pero sí define muchos conceptos fundamentales, de lectura obligada aunque creas que sabes de semáforos.

<<futex>>:: Es una interfaz del núcleo Linux diseñada específicamente para que las librerías implementen mecanismos de sincronización de procesos de forma muy eficiente. Quizás este es el segundo capítulo en complejidad pero me parece importante porque enseña cómo se implementan a bajo nivel las primitivas de sincronización que usan las librerías más importantes (incluidas las POSIX Threads) y máquinas virtuales. Dado que es una interfaz de interacciones complejas entre el núcleo y procesos de usuario es difícil encontrar buena documentación de introducción, este capítulo llena ese hueco. No es necesario leerlo para comprender los otros pero es uno de los que más he disfrutado escribiendo.

<<monitors>>:: La construcción de monitores se inventó para solucionar los mismos problemas de sincronización que los semáforos pero de una forma más estructurada. A pesar de que es una construcción sintáctica de un lenguaje tan popular como Java pocos programadores lo conocen. Quizás se deba a que en los libros de texto se enseñan monitores con el casi desaparecido _Concurrent Pascal_ o ADA y se sedimenta la idea de que es un concepto antiguo o abandonado. Creo que la lectura es bastante accesible, de interés para todos los programadores, especialmente los que programan en Java o con las librerías POSIX Threads (las variables de condición surgieron de los monitores).

<<channels>>:: Los canales están basados en el concepto de _comunicación de procesos secuenciales_ que inventó Hoare en 1978, es un modelo genérico de computación de procesos independientes que se comunican y sincronizan únicamente a través de mensajesfootnote:[Otros modelos de más alto nivel, como _actores_ o _agentes asíncronos_ son similares y/o derivados de _CSP_.]. Los canales ofrecen las mismas posibilidades de sincronización que semáforos y monitores, además permiten la comunicación sin compartir memoria por lo que facilita la implementación de procesos independientes que pueden ejecutarse en paralelo. Erlang es un lenguaje que se basa en el modelo _CSP_, en 2010 se publicó la primera versión de Go, otro lenguaje basado en los mismos conceptos, es muy probable que en tu vida profesional debas programar en un lenguaje que use canales. Al final del capítulo se muestran ejemplos sencillos pero claves de computación en paralelo y distribuida con canales. El capítulo es fácil de leer, con todos sus ejemplos en Go (interesante también para los que quieran aprender Go o aprender los patrones básicos de concurrencia con canales).

=== Fe de erratas
Este libro está autoeditado, no fue revisado por editores ni correctores profesionales.  Aunque revisé cada capítulo varias veces, publiqué los manuscritos https://gallir.wordpress.com/principios-de-concurrencia/[en mi blog] y antes de publicarse pasó por la revisión de varios amigos y conocidos seguro que tiene errores. Pido disculpas por adelantado y me comprometo a actualizarlo con las correcciones en todas las plataformas en las que lo haya publicado.
