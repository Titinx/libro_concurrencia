[preface]
== Prefacio

Hace más de veinte años que enseño temas de concurrencia, primero en las asignaturas de _Sistemas Operativos I_ y _II_, luego en una específica, _Programación Concurrente y Distribuida_ de la carrera de informática en la Universitat de les Illes Balears. A pesar de la cantidad de notas y presentaciones que elaboré en todos estos años nunca se me pasó por la cabeza escribir un libro, ni siquiera los típicos libros de asignaturas editados por las universidades. Es muy complicado explicar los problemas de concurrencia a alumnos con poca experiencia en programación, por más que el profesor insista con ejemplos en la pizarra es muy difícil hacer que los alumnos capten las sutilezas y conflictos generados por las ejecuciones que no cumplen con la _secuencialidad_ de los programas.

Pero eso cambió en diciembre de 2014.

=== Motivación
Un amigo programador que no tuvo la fortuna de estudiar infomática se encontró con un problema de _estructuras concurrentes_. Quería aprender más sobre el tema y me preguntó en Twitter qué bibliografía le recomendaba y me metió en un problema serio.

Hay muy buenos libros de texto sobre concurrencia pero además de ser caros (en general superan los 60 €) están muy orientados a la parte formal del problema, no a las aplicaciones prácticas. También suelen usar lenguajes y formalismos poco usados (Promela, Concurrent Pascal, Spaces, ADA) que no tienen sentido para un programador que quiere aprender o actualizarse y poder transferir rápidamente esos conocimientos a su lenguaje preferido.

Hay buenos libros orientados a divulgación y actualización (como <<Herlihy12>>) pero que además de caros están especializados en pocos temas y orientados a una audiencia más acádemica. También hay buenos libros escritos para un lenguaje en particular (como Java) y sus herramientas pero no explican los orígenes y principios fundamentanles de concurrencia.

Mientras buscaba bibliografía y explicaba estos problemas a mi amigo, él buscaba por su cuenta en los apuntes y notas de clase de las universidades más prestigiosas. Estaban bien, pero la mayoría estaban pensados mas como soporte de clases que como un texto estructurado que cubriese lo que se consideran los principios y algoritmos fundamentales.

No hice un extenso análisis de mercado pero en unas pocas horas me di cuenta que me fue imposible recomendar un libro que explicase _concurrencia_ de la forma que yo consideraba era la más útil y valiosa para un programador que está interesado en conocer sus _principios_.

Casi como una broma respondí ''a ver si tengo que escribirlo en un ebook'' lo que generó inmediatas peticiones para que lo hiciese.

Así es como surgió este libro, no sabía en lo que me metía. Pensé que lo podría hacer en tres meses con menos de 20 000 palabras, pero acabó teniendo más de 55 000 además de 22 000 líneas de código en cinco lenguajes diferentes escritos exclusivamente para este libro.

Creo que en el libro logro explicar, con ejemplos en lenguajes modernos y muy populares, lo que considero fundamental de los principios y algoritmos fundamentales de concurrencia. Por supuesto esto es una opinión subjetiva y cada lector tendrá su opinión y divergencia sobre por qué no cuento esa característica tan especial de su lenguaje preferido. Es muy difícil explicar o refutar esas opiniones, se necesitaría un macroensayo filosófico, pero tengo la ventaja de haber enseñado estos temas durante dos décadas. No solo sé lo que me ha costado dominar ciertos temas, sino también lo que cuesta transmitir y hacer _captar_ las sutilezas de la programación concurrente.

No se trata de aprender de memoria unos algoritmos ni de saber exactamente cómo y cuándo usarlos, se trata de otra forma de pensar la programación. Las cosas ya no son lineales ni los invariantes tan obvios, has de razonar de forma muy diferente. No se trata de solo _este programa_, sino de cómo puede interactuar con _otros_ y cómo afecta la ejecución de esos _otros_ a los resultados de _éste_. Hay que pensar también de forma _concurrente_, no se adquiere con una asignatura ni leyendo un libro durante un fin de semana. Requiere motivación y entrenamiento, pero no cabe duda que un libro que explique lo fundamental y lo acompañe con código de demostración y prueba es de gran ayuda al proceso.

Me temo que no había un libro de ese tipo, no al menos para el público objetivo de este libro: el programador que no tuvo la suerte de una formación universitaria, o que quiere actualizarse, o que sencillamente no recuerda a esa oscura asignatura de hace años y hoy tiene las ganas o la necesidad de recordarlo.

Ante esta situación y dado que el tiempo para escribir un libro es finito, filtrar y seleccionar lo fundamental, separar lo fundamental de lo que son derivaciones o metaconstrucción sobre esos pilares básicos. Lo tenía claro e hice el esfuerzo, no sé si están todos los que son pero sí sé que los que están son fundamentales.

=== Escribir un _eBook_ técnico legible
Este libro tiene muchos algoritmos y programas completos. Mis experiencias con libros electrónicos técnicos no son de las mejores, sobre todo si incluyen ejemplos de programas cuyas líneas no alcanzan a mostrarse completas en la pequeña pantalla del lector o del tablet. Me duele la cabeza de solo recordarlo, sobre todo los que incluyen hasta el tratamiento de excepciones, hay que hacer un gran esfuerzo para descrifrar entre tanto galimatías la parte importante del algoritmo.

Al momento que escribo estas líneas no sé si habrá una versión impresa del libro, no contacté con ninguna editorial, la intención fue desde el principio hacer un _ebook_ que fuese accesible, compacto y con ejemplos. No es fácil escribir un libro electrónico técnico cuyo código fuese legible, fui muy cuidadoso en este aspecto.

Una clave es escribir los algoritmos en pocas líneas, que sea suficientemente expresivo pero a la vez breve para que una línea de código sea también una línea de la pantalla. En vez de inventar otro pseudocódigo usé directamente Python, no solo es expresivo, es fácil de comprender y los programas son válidos.

Por las mismas razones muchos de los ejemplos están escritos en Python, pero solo si era el más adecuado para mostrar el funcionamiento y los problemas tratados. Los ejemplos están en cinco lenguajes diferentes (C, Python, Java, Go y ensamblador de ARM), usé siempre el que me parece el más apropiado para demostrar lo que estaba explicando. En algunos casos traduje el código a Python para explicarlo en el texto, en otros casos usé el lenguaje original pero los simplifiqué quitanto lo accesorio (como una larga lista de argumentos, tratamiento de excepciones y nombres de funciones).

De todas formas me parece importante, y es lo que yo espero de un libro, poder ver el código completo. Dado que no tiene las restricciones de un libro físico decidí que todo el código debía estar disponible directamente desde el lector sin necesidad de conectarse a internet ni picar URLs en un ordenador. El código completo de todos los ejemplos <<source_code, están en los apéndices>> al final del libro (aproximadamente el 30% del total de contenido del libro), cada uno de ellos está enlazado desde el texto donde se discute el código simplificado. En el apéndice, justo arriba del código, está el enlace al código correspondiente en https://github.com/gallir/concurrencia_source_samples[Github].

Creo que en este aspecto cumplí los objetivos, el código de los ejemplos en el texto es legible fácilmente -aún en pantallas de teléfonos-, va directo al punto que interesa y no necesitan tres pantallas para leerlo completo. Pero con un _clic_ se puede ver el código completo sin salir del libro, y con otro _clic_ se puede acceder al repositorio para bajarlo a un ordenador.


=== Sobre el contenido
No fue la intención original pero este libro completamente, y con algo más, los contenidos de concurrencia que se suelen dar en las universidades. Hace unos años estos temas se daban en las asignaturas de _sistemas operativos_, fue en esta área donde primero aparecieron los problemas de concurrencia, era natural que se explicasen en estas asignaturas. Pero el área de concurrencia se amplió y profundizó, ya tiene peso e importancia por sí mismafootnote:[Algunos consideramos que es clave en la formación, forma parte de los _principios fundamentales_ de la informática.] por lo que ya existen asignaturas específicas de _programación concurrente_ en la mayoría de carreras de informática. Este libro cubre todos los temas de concurrencia que se dan en esas asignaturas y que sería el equivalente a aproximadamente un semestre.

Una de las carencias más importantes de la docencia es que no se suele enseñar temas que avanzaron mucho en los últimos años, como el diseño de algoritmos de _spinlocks_ con instrucciones de hardware o las interfaces de los sistemas operativos para la programación de primitivas de sincronización como _FUTEX_. Es razonable esa carencia, el tiempo es finito y no suelen estar incluidos en los libros de texto de sistemas operativos ni de programación concurrente. Creo que los dos temas mencionados son complejos pero importantes, por eso dediqué un capítulo a cada uno de ellos con ejemplos de las técnicas y algoritmos más usados.

Intenté que este libro sea compacto e ir directamente al grano sin demasiadas analogías pueriles como es habitual en los libros de texto. A pesar del esfuerzo deliberado por la brevedad la longitud final es equivalente a unas 250 páginas (sin contar el listado de los programas) de un libro impreso. Cada párrafo suele describir completamente una idea o concepto, cada oración es un avance hacia ese objetivo. La lectura puede dar la sensación de agobio por la rapidez con que se avanza, también me pasaba durante las revisiones y correcciones.

Pido disculpas por no saber hacerlo mejor, pero en cierta forma es inevitable si se escribe un texto donde se introducen tantos temas complejos. En mi defensa debo decir que vivimos en una época donde el conocimiento está al alcance de unos pocos clics. Para facilitarlo fui cuidadoso con la bibliografía, aunque intenté referenciar a los artículos científicos originales también me tomé el trabajo de buscarlos en internet (en algunos casos llevó trabajo encontrar artículos de los años 60 y 70) y añadir el enlace.

==== Los programas y lenguajes
Uno de los requisitos que me impuse fue que todo lo que explicase debía ir acompañado de un código compilable y funcional. Otro fue que todos deberían poder se compilados y ejecutados en el ordenador más básico posible, a día de hoy cualquier Raspberry con sus distribuciones estándares de GNU/Linux. Solo se necesita instalar los paquetes del gcc, Golang, Python y el SDK de Java, todos disponibles en cualquier distribución para Raspberry u ordenadores de escritorio. Los programas están desarrollados para que funcionen sobre Raspberry 1 y 2 y probados con Debian Jessie y Ubuntu 14.04, para generar sus ejecutables solo hay que ejecutar el comando +make+ en cada uno de sus directorios.

La regla para usar uno u otro lenguaje de programación fue elegir el más apto para el tema que se discute, si era una buena opción usaba Python. Para _monitores_ usé principalmente Java porque es un lenguaje muy popular que incluye a los monitores como construcción sintáctica del lenguaje. Para _canales_ usé Go por la misma razón, los canales son una construcción del lenguaje.

Hay bastantes ejemplos en C, lo usé cuando no había opción de hacerlo en otro lenguaje o porque éste era el más adecuado para ese caso. Mi opinión es que todos los programadores deberían saber C, su gramática es muy sencilla y a la vez está muy próximo a la arquitectura. Si no se conoce ensamblador es la mejor forma de tener una idea de las transformaciones que deben hacer los intérpretes y máquinas virtuales (la mayoría de ellas programadas en C o C++) para pasar de abstracciones de alto nivel a código ejecutable por el procesador. En general es notable la diferencia de calidad de código de los programadores que conocen qué ocurre tras las bambalinas de la máquina virtual respecto a los que lo ignoran completamente. Pero no te preocupes si no sabes C, los programas son breves, se usan siempre las mismas funciones y están explicados -a veces línea a línea-.

Usé ensamblador en un <<stack_llsc_freelist_s, único caso>>, no había otra opción para demostrar el funcionamiento de las instrucciones de sincronización de _LL/SC_. Afortunadamente los procesadores ARM de ambos modelos de Raspberry (ARMv6 y ARMv7) soportan esas instrucciones, por lo que no hace falta hardware especial o caro.

En algunos algoritmos hay ejemplos en varios lenguajes diferentes, me pareció oportuno mostrarlos cómo se hacen en cada uno de ellos, o cómo se pueden construir mecanismos similares (notablemente simular monitores en C y Python). Para los que conozcan un lenguaje mejor que otro puede ser clarificador. De todas maneras nunca está mal acostumbrarse a interpreter algoritmos en varios lenguajes, es la mejor forma de perder el miedo a aprender lenguajes.

==== Terminología
Escribí el libro en castellano porque pensé que sería mucho más sencillo que hacerlo en inglés, ahora pienso que quizás me complicó más. No leo libros técnicos de informática en castellano, siempre en su original en inglés por lo que no domino la terminología técnica en castellano. He tenido que dedicar mucho tiempo a encontrar las traducciones adecuadas para los nombres técnicos, espero haber hecho un buen trabajo. Pero me negué a traducir algunas palabras que son parte de nuestro vocabulario habitual como _array_, _buffer_, _spinlock_ o _scheduler_.

Una parte importante del aprendizaje y entrenamiento de cualquier área de conocimiento es conocer la terminología técnica, ésta permite la discusión y transmisión del conocimiento de forma más compacta y sin ambigüedades. Para bien o para mal la lengua vehicular de la informática es el inglés por lo que es importante conocer también la terminología técnica en ese idioma. En este aspecto también fui cuidadoso de poner su equivalente en inglés cada vez que introduzco un concepto o palabra nueva.

Tampoco es fácil seleccionar una palabra en particular, muchas veces doy varios sinónimos -en castellano y en inglés- porque no hay un consenso unánime y universal. Algunos términos se usan más en el entorno científico (como _lock-free_ y _critical section_) y en ingeniería se refieren a lo mismo con otros diferentes (_deadlock-free_ y _mutual exclusion_ respectivamente), para estos casos inicialmente describo ambos términos (en inglés y castellano) y los uso indistintamente.


==== Estructura

<<processes_concurrency>>:: Es la introducción a concurrencia, procesos e hilos y cómo son gestionados y planificados por el sistema operativo. Describe el problema del intercalado y cómo es el responsable de los problemas de concurrencia. Me parece que es un capítulo sencillo de entender y de lectura fácil pero importante porque define con claridad qué es la _programación concurrente_ y por qué no debe confundirse con paralelismo.

<<mutual_exclusion>>:: Describe las soluciones por software al problema fundamental de concurrencia, la exclusión mutua. Se comienzan con los casos más sencillos para dos procesos hasta acabar en soluciones genéricas. Su objetivo también es enseñar cómo se razonan, diseñan y evalúan los programas concurrentes. Si tienes experiencia con programación concurrente y conocen el algoritmo de la panadería podrías saltarte este capítulo, pero si no tienes experiencia o no recuerdas los requisitos y sus razones es de lectura obligada.

<<barriers>>:: Las soluciones por software no funcionan si no se tiene en cuenta la evolución y funcionamiento de los procesadores modernos, arquitecturas de multiprocesamiento y modelos de coherencia de la memoria caché. De lectura obligada si no sabes por qué los procesadores no aseguran la consistencia secuencial o qué son las barreras de memoria.

<<hardware>>:: Se describen las instrucciones de hardware diseñadas para facilitar la sincronización de procesos, cómo usarlas para solucionar la exclusión mutua con _spinlocks_ básicos, los problemas _ocultos_ y sus soluciones. Salvo la última parte donde se discute y soluciona el _problema ABA_ no me parece un capítulo muy complejo pero sí muy pedagógico del porqué y cómo se diseñan las operaciones atómicas de los procesadores.

<<spinlocks>>:: Es el capítulo más extenso y quizás el más complejo, trata temas que habitualmente no aparecen en los libros de texto (quizás por la complejidad). Avanza en el tema de _spinlock_, explica cómo hacer más eficientes los _spinlocks_ simples y los algoritmos más complejos desarrollados recientemente. Es de lectura obligada para los que pretenden convertirse en programadores de sistemas operativos, de sistemas empotrados, o de los que tienen que trabajar con _estructuras concurrentes_ muy usadas en bases de datos, máquinas virtuales o intérpretes de lenguajes.

<<semaphores>>:: Con éste comienza una segunda parte bien diferenciada, mientras que en los anteriores capítulos se trataban algoritmos con espera activa a partir de este se tratan las soluciones para evitar esas esperas activas haciendo que los procesos se bloqueen cuando no deben continuar. El concepto de semáforos fue el primero en este sentido, lo inventó Dijkstra a finales de la década de 1960 y es sin duda un pilar fundamental de todas las construcciones posteriores para sincronización de procesos. No me parece un capítulo complejo pero sí define muchos conceptos fundamentales, de lectura obligada aunque creas que sabes de semáforos.

<<futex>>:: Es una interfaz del núcleo Linux diseñada específicamente para que los programas y librerías implementen mecanismos de sincronización de procesos de forma muy eficiente. Quizás este es el segundo capítulo en complejidad pero me parece importante porque enseña cómo se implementan a bajo nivel las primitivas de sincronización que usan todos las librerías (incluidas las POSIX Threads) y maquinas virtuales. Dado que es una interfaz de interacciones complejas entre el núcleo y el proceso de usuario es difícil encontrar buena documentación de introducción y no se suele estudiar nada similar en las asignaturas universitarias. No es necesario leer este capítulo para comprender los demás pero es uno de los que más he disfrutado escribiendo, no entendería a los programadores que no les interese este tipo de detalles.

<<monitors>>:: La construcción de monitores se inventó para solucionar los mismos problemas de sincronización que los semáforos de una forma más estructurada. A pesar que es una construcción sintáctica de un lenguaje tan popular como Java pocos programadores lo conocen. Quizás se deba a que en los libros de texto se enseñan monitores con el casi desaparecido _Concurrent Pascal_ o ADA y se sedimenta la idea de que es un concepto antiguo o abandonado. Creo que la lectura es bastante accesible, de interés para todos los programadores, especialmente los que programan en Java o con las librerías POSIX Threads (las variables de condición surgieron de los monitores).

<<channels>>:: Está basado en el concepto de _comunicación de procesos secuenciales_ que inventó Hoare en 1978 como un modelo genérico de computación de procesos independientes que se comunican y sincronizan unicamente a través de intercambio de mensajes atómicos. Otros modelos de más alto nivel, como _actores_ o _agentes asincrónicos_ son similares y/o derivados de _CSP_. La ventaja de los canales es que no requiere compartir memoria, de hecho la idea es no tener que hacerlo nunca. Libera de los problemas de exclusion mutua en recursos compartidos y facilita la implementación de procesos independientes que pueden ejecutarse en paralelo. Erlang es un lenguaje que se basa en el modelo _CSP_, en 2010 se publicó la primera versión de Go, otro lenguaje basado en los mismos conceptos, es muy probable que en tu vida profesional debas programar en un lenguaje que use canales. Al final del capítulo se muestran ejemplos sencillos pero claves de computación en paralelo y distribuida con canales. El capítulo es fácil de leer, con todos sus ejemplos en Go (interesante también para los que quieran aprender Go o aprender los patrones básicos de concurrencia con canales).
