[preface]
== Prefacio

Hace más de veinte años que enseño temas de concurrencia, primero en las asignaturas de _Sistemas Operativos I_ y _II_, luego en una específica, _Programación Concurrente y Distribuida_ de la carrera de informática en la Universitat de les Illes Balears. A pesar de la cantidad de notas y presentaciones que elaboré en todos estos años nunca se me pasó por la cabeza escribir un libro, ni siquiera los típicos libros de asignaturas editados por las universidades. Es muy complicado explicar los problemas de concurrencia a alumnos con poca experiencia en programación, por más que el profesor insista con ejemplos en la pizarra es muy difícil hacer que los alumnos capten las sutilezas y conflictos generados por las ejecuciones que no cumplen con la _secuencialidad_ de los programas.

Pero eso cambió en diciembre de 2014.

=== Motivación
Un amigo programador que no tuvo la fortuna de estudiar infomática se encontró con un problema de _estructuras concurrentes_. Quería aprender más sobre el tema y me preguntó en Twitter qué bibliografía le recomendaba y me metió en un problema serio.

Hay muy buenos libros de texto sobre concurrencia pero además de ser caros (en general superan los 60 €) están muy orientados a la parte formal del problema, no a las aplicaciones prácticas. También suelen usar lenguajes y formalismos poco usados (Promela, Concurrent Pascal, Spaces, ADA) que no tienen sentido para un programador que quiere aprender o actualizarse y poder transferir rápidamente esos conocimientos a su lenguaje preferido.

Hay buenos libros orientados a divulgación y actualización (como <<Herlihy12>>) pero que además de caros están especializados en pocos temas y orientados a una audiencia más acádemica. También hay buenos libros escritos para un lenguaje en particular (como Java) y sus herramientas pero no explican los orígenes y principios fundamentanles de concurrencia.

Mientras buscaba bibliografía y explicaba estos problemas a mi amigo, él buscaba por su cuenta en los apuntes y notas de clase de las universidades más prestigiosas. Estaban bien, pero la mayoría estaban pensados mas como soporte de clases que como un texto estructurado que cubriese lo que se consideran los principios y algoritmos fundamentales.

No hice un extenso análisis de mercado pero en unas pocas horas me di cuenta que me fue imposible recomendar un libro que explicase _concurrencia_ de la forma que yo consideraba era la más útil y valiosa para un programador que está interesado en conocer sus _principios_.

Casi como una broma respondí "a ver si tengo que escribirlo en un ebook" lo que generó inmediatas peticiones para que lo hiciese.

Así es como surgió este libro, no sabía en lo que me metía. Pensé que lo podría hacer con menos de 20 000 palabras y en unos tres meses, pero acabó teniendo más de 50 000 además de las 22 000 líneas de código en cinco lenguajes diferentes escritos exclusivamente para este libro.

Creo que en el libro logro explicar, con ejemplos en lenguajes modernos y muy populares, lo que considero fundamental de los principios y algoritmos fundamentales de concurrencia. Por supuesto esto es una opinión subjetiva y cada lector tendrá su opinión y divergencia sobre por qué no cuento esa característica tan especial de su lenguaje preferido. Es muy difícil explicar o refutar esas opiniones, se necesitaría un macroensayo filosófico, pero tengo la ventaja de haber enseñado estos temas durante dos décadas. No solo sé lo que me ha costado dominar ciertos temas, sino también lo que cuesta transmitir y hacer _captar_ las sutilezas de la programación concurrente.

No se trata de aprender de memoria unos algoritmos ni de saber exactamente cómo y cuándo usarlos, se trata de otra forma de pensar la programación. Las cosas ya no son lineales ni los invariantes tan obvios, has de razonar de forma muy diferente. No se trata de solo _este programa_, sino de cómo puede interactuar con _otros_ y cómo afecta la ejecución de esos _otros_ a los resultados de _éste_. Hay que pensar también de forma _concurrente_, no se adquiere con una asignatura ni leyendo un libro durante un fin de semana. Requiere motivación y entrenamiento, pero no cabe duda que un libro que explique lo fundamental y lo acompañe con código de demostración y prueba es de gran ayuda al proceso.

Me temo que no había un libro de ese tipo, no al menos para el público objetivo de este libro: el programador que no tuvo la suerte de una formación universitaria, o que quiere actualizarse, o que sencillamente no recuerda a esa oscura asignatura de hace años y hoy tiene las ganas o la necesidad de recordarlo.

Ante esta situación y dado que el tiempo para escribir un libro es finito, filtrar y seleccionar lo fundamental, separar lo fundamental de lo que son derivaciones o metaconstrucción sobre esos pilares básicos. Lo tenía claro e hice el esfuerzo, no sé si están todos los que son pero sí sé que los que están son fundamentales.

=== Hacer un ebook
Este libro tiene muchos algoritmos y código completo. Mis experiencias con ebooks técnicos no son de las mejores, sobre todo si incluyen ejemplos de programas cuyas líneas no alcanzan a mostrarse completas en la pequeña pantalla del lector de ebooks o del tablet. Me duele la cabeza de solo recordarlo, sobre todo los que incluyen hasta el tratamiento de excepciones, hay que hacer un gran esfuerzo para descrifrar entre tanto galimatías la parte importante del algoritmo.

Al momento que escribo estas líneas no sé si habrá una versión impresa del libro, no contacté con ninguna editorial, la intención fue desde el principio hacer un ebook que fuese accesible, compacto y sobre todo que el código fuese legible. No es fácil escribir un libro electrónico técnico cuyo código fuese legible, fui muy cuidadoso en este aspecto.

Una clave es lograr escribir el algoritmo en pocas líneas, que sea suficientemente expresivo pero a la vez breve para que una línea de código sea también una línea de la pantalla. En vez de inventar otro pseudocódigo usé directamente Python, no solo es expresivo, es fácil de comprender y los programas son válidos.

Por las mismas razones muchos de los ejemplos están escritos en Python, pero solo si era el más adecuado para mostrar el funcionamiento y los problemas tratados. Los ejemplos están en cinco lenguajes diferentes (C, Python, Java, Go y ensamblador de ARM), usé siempre el que me parece el más apropiado para demostrar lo que estaba explicando. En algunos casos traduje el código a Python para explicarlo en el texto, en otros casos usé el lenguaje original pero los simplifiqué quitanto lo accesorio (como una larga lista de argumentos, tratamiento de excepciones y nombres de funciones).

De todas formas me parece importante, y es lo que yo espero de un libro, poder ver el código completo. Dado que no tiene las restricciones de un libro físico decidí que todo el código debía estar disponible directamente desde el lector sin necesidad de conectarse a internet ni picar URLs en un ordenador. El código completo de todos los ejemplos <<source_code, están en los apéndices>> al final del libro (aproximadamente el 30% del total), cada uno de ellos está enlazado desde el texto donde se discute el código simplificado. En el apéndice, justo arriba del código, está el enlace al código correspondiente en https://github.com/gallir/concurrencia_source_samples[Github].

Creo que en este aspecto cumplí los objetivos, el código de los ejemplos en el texto es legible fácilmente -aún en pantallas de teléfonos-, va directo al punto que interesa y no necesitan tres pantallas para leerlo completo. Pero con un _clic_ se puede ver el código completo sin salir del libro, y con otro _clic_ se puede acceder al repositorio para bajarlo a un ordenador.

=== Los programas y lenguajes
Uno de los requisitos que me impuse fue que todo lo que explicase debía ir acompañado de un código compilable y funcional. Otro fue que todos deberían poder se compilados y ejecutados en el ordenador más básico posible, a día de hoy cualquier Raspberry con sus distribuciones estándares de GNU/Linux. Solo se necesita instalar los paquetes del gcc, Golang, Python y el SDK de Java, todos disponibles en cualquier distribución para Raspberry u ordenadores de escritorio. Los programas están desarrollados para que funcionen sobre Raspberry 1 y 2 y probados con Debian Jessie y Ubuntu 14.04, para generar sus ejecutables solo hay que ejecutar el comando +make+ en cada uno de sus directorios.

La regla para usar uno u otro lenguaje de programación fue elegir el más apto para el tema que se discute, si era una buena opción usaba Python. Para _monitores_ usé principalmente Java porque es un lenguaje muy popular que incluye a los monitores como construcción sintáctica del lenguaje. Para _canales_ usé Go por la misma razón, los canales son una construcción del lenguaje.

Hay bastantes ejemplos en C, lo usé cuando no había opción de hacerlo en otro lenguaje o porque éste era el más adecuado para ese caso. Mi opinión es que todos los programadores deberían saber C, su gramática es muy sencilla y a la vez está muy próximo a la arquitectura. Si no se conoce ensamblador es la mejor forma de tener una idea de las transformaciones que deben hacer los intérpretes y máquinas virtuales (la mayoría de ellas programadas en C o C++) para pasar de abstracciones de alto nivel a código ejecutable por el procesador. En general es notable la diferencia de calidad de código de los programadores que conocen qué ocurre tras las bambalinas de la máquina virtual respecto a los que lo ignoran completamente. Pero no te preocupes si no sabes C, los programas son breves, se usan siempre las mismas funciones y están explicados -a veces línea a línea-.

Usé ensamblador en un <<stack_llsc_freelist_s, único caso>>, no había otra opción para demostrar el funcionamiento de las instrucciones de sincronización de _LL/SC_. Aofrtunadamente los procesadores ARM de ambos modelos de Raspberry (ARMv6 y ARMv7) soportan esas instrucciones, por lo que no hace falta hardware especial o caro.

En algunos algoritmos hay ejemplos en varios lenguajes diferentes, me pareció oportuno mostrarlos cómo se hacen en cada uno de ellos, o cómo se pueden construir mecanismos similares (notablemente simular monitores en C y Python). Para los que conozcan un lenguaje mejor que otro puede ser clarificador. De todas maneras nunca está mal acostumbrarse a interpreter algoritmos en varios lenguajes, es la mejor forma de perder el miedo a aprender lenguajes.


=== Terminología
Escribí el libro en castellano porque pensé que sería mucho más sencillo que hacerlo en inglés, ahora pienso que quizás me complicó más. No leo libros técnicos de informática en castellano, siempre en su original en inglés por lo que no domino la terminología técnica en castellano. He tenido que dedicar mucho tiempo a encontrar las traducciones adecuadas para los nombres técnicos, espero haber hecho un buen trabajo. Pero me negué a traducir algunas palabras que son parte de nuestro vocabulario habitual como _array_, _buffer_ o _scheduler_.

Una parte importante del aprendizaje y entrenamiento de cualquier área de conocimiento es conocer la terminología técnica, ésta permite la discusión y transmisión del conocimiento de forma más compacta y sin ambigüedades. Para bien o para mal la lengua vehicular de la informática es el inglés por lo que es clave conocer también la terminología técnica en ese idioma. En este aspecto también fui cuidadoso de poner su equivalente en inglés cada vez que introduzco un concepto o palabra nueva.

Tampoco es fácil seleccionar una palabra en particular, muchas veces doy varios sinónimos -en castellano y en inglés-. Algunos términos se usan más en el entorno científico (como _lock-free_ y _critical section_) y en ingeniería se refieren a lo mismo con otros diferentes (_deadlock-free_ y _mutual exclusion_ respectivamente), para estos casos inicialmente describo ambos términos (en inglés y castellano) y los uso indistintamente.




=== Estructura
