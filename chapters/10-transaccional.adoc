== 10. Memoria transaccional... en proceso



Los problemas de locks:

- Producen inversión de prioridades y efecto convoy, interbloqueo es difícil de evitar si se manipulan muchos objetos. Con tantos programas concurrentes es muy costoso tener expertos en concurrencia.

- Las primitivas atómicas solo trabajan con una palabra a la vez, resulta en algoritmos complejos y algunos temas académicamente no resueltos (como las lista de doble entrada con posibilidad de añadir o extraer por ambos extremos).

- El problema de la composición. Algoritmos de _spinlocks_ complejos por la dificultad de componer llamadas a múltiples objetos en unidades atómicas. En spinlocks <<free_lock_stack>> vimos como implementar una pila sin exclusión mutua, no se puede eliminar el elemento de una e insertarla en otra atómicamente, no son _componibles_. Se pueden agregar mecanismos _ad hoc_, como añadir otro spinlock o exclusión mutua adicional pero eso crearía un cuello de botella.

Es decir no son _componibles_.





- Son difíciles de gestionar efectivamente, especialmente en grandes sistemas. Lo que desea el programador es indicar cuál es la sección crítica y que el sistema se encargue de controlar la granularidad. Se usan _mutex_ (o _locks_) globales para gestionar estructuras complejas como hashing o árboles balanceados por la complicación de granularidades más pequeñas. Esto afecta negativamente al paralelismo.


Los _mutex_ son pesismistas, las transacciones optimistas y tentativas.
En paralelismo no hay mecanismos de abstracción y composición. Composición es la capacidad de juntar dos entidades para forma una más compleja.

Mover un objeto de una cola a otra de forma atómica es imposible con monitores, sin embargo es trivial con transacciones.

atomic {
    x = q0.deq();
    q1.enq(x);
}



Funciones
----
StartTX()
x = LoadTX(ptr)
x += 1
StoreTX(ptr, x)
CommitTx()
----

bloques:
----
transaction {
    a = b * x
}
----

La palabra clave transaction es similar a synchronized en Java, pero mientras synchronized adquiere un _lock_ específico, atomic lo es respecto a todos los demás bloques atómicos.

Como las transacciones permiten actualizaciones a diferentes ubicaciones eliminan la necesidad de comparaciones múltiples en los spinlocks.

Las transacciones son ejecutadas especulativamente, hace cambios tentativos a objetos, si acaban sin conflictos se hace el _commit_ definitivo. Si no, se aborta. Las transacciones pueden ser anidadas, son útiles porque pueden ser abortadas sin abortar al padre.






----
void push(node **head, node *e) {
    __transaction_atomic {
        e->next = *head;
        *head = e;
    }
}

node *pop(node **head) {
    node *old_head;

    __transaction_atomic {
        old_head = *head;
        if (old_head) {
            *head = old_head->next;
        }
    }
    return old_head;
}
----




=== Transacciones en bases de datos

Las base de datos son capaces de trabajar concurrentemente y en paralelo desde hace tiempo, ejecutan varias consultas simultáneamente cuando es posible.

La popularización de los multi cores ha hecho renacer el interés de estas técnicas. Aunque se parecen ambas tienen diferencias. Una involucra acceso a disco, la otra comunicación por red.






En corazón del sistema es la transacción, espeficica una secuencia de operaciones (una composición) como si fuese la única accediendo a la base de datos.

Las operaciones se ejecutan en paralelo pero están limitadas las interacciones de forma que los resultados no varían si se ejecutaron una después de otra o al revés. Esta propiedad se llama _serialibilidad_. Simplifca el "mundo" del programador.

Las bases de datos tienen las propiedades ACID por atomicidad, consistencia, aislamiento (_isolation_) y durabilidad.

Atomicidad significa que el conjunto de operaciones de una transacción se completan todas o ninguna. Si se _rechaza_ una ejecución no debe dejar rastros. Cuando una transacción acaba correctamente se hace el _commit_, caso contrario la transacción de _aborta_.

Consistencia significa que los datos pasan de un estado consistente a otro. Por ejemplo, se respetan los invariantes, por ejemplo que el resultado de una transferencia bancaria que generó un ingreso en una cuenta también está representado la salida, no puede aparece dinero de más en la suma de ambas.

Durabilidad es que los datos queden permanentemente almacenados en un dispositivo persistente. ¿¿¿¿No se aplica a la memoria transaccional????


=== Origenes

La memoria transaccional está en su infancia. La primera propuesta para usar la idea de transacciones fue de David Lomet en 1977 (<<Lomet>>) pero no propuso ninguna solución práctica competitiva con los mecanismos de sincronización explícitos (<<Harris>>). La idea cayó en el olvido hasta 1993. Maurice Herlihy y Eliot Moss (<<Herlihy93>>) propusieron soluciones para soporte de hardware de transacciones para superar las limitaciones de los _spinlocks_, principalmente la inversión de prioridaddes, efecto convoy y los interbloqueos.

Janice Stone _et al_ (<<Stone>>) propusieron primitvas de hardware atómicas _multi-palabra_ (_Read-and-Reserve/Write-if-Reserved_) conocidas como _Oklahoma Update_. La propuesta está basada en la misma idea de LL/SC (<<llsc>>) pero a diferencia es esta permite reservar más de una palabra.

En 1995 Nir Shavit y Dan Touitou (<<Shavit>>) fueron los primeros en proponer la memoria transaccional por software.


==== Sistemas
A simulator is available for ASF, a proposed AMD64 architecture extension for bounded-size transactions [61]. This is based on PTLSim, providing a detailed, cycle-accurate full-system simulation of a multi-core system
TL2
CTL
Deuce STM provee métodos atómicos para Java.
JVSTM is a Java library that implements a multi-versioned approach to STM that includes
mechanisms for partial re-execution of failed transactions
The Sun C++ compiler with Transactional Memory supports a range of STM back-ends, including TL2 [83], SkySTM [188], HyTM [78] and PhTM [193].The compiler is available in binary format, but the runtime system and additional TM implementations are available as source code by request from the Sun Labs Scalable Synchronization Research Group. http://research.sun.com/scalable/
TinySTM is a word-based STM implementation available from the University of Neuchatel. It is based on the LSA algorithm [262]. A Java LSA implementation is also available. http://tmware.org
Implementations of TL2 [83] and subsequent algorithms are available for use with Tanger (an earlier version of DTMC). http://mcg.cs.tau.ac.il/projects
TxOS is a prototype version of Linux that extends the OS to allow composition of system calls into atomic, isolated operations [243]. TxOS supports transactional semantics for a range of resources, including the file system, pipes, signals, and process control. It runs on commodity hardware. http://txos.code.csres.utexas.edu

=== Diseño

==== Control de concurrencia

La ocurrencia del conflicto, la detección y la resolución, ocurren siempre en el mismo orden.

El _control de concurrencia pesimista_ detecta el conflicto en cuanto se produce, los tres se producen al mismo tiempo. Cada transacción se apropia de los datos y las demás no pueden acceder a ellos.

Con el control optimista la detección y resolución puede ocurrir más tarde. Permite que varias transacciones accedan simultáneamente al mismo dato.

==== Gestión de versiones

- Eager version management [227] o direct update, se modifica directamente en la memoria y se mantiene un undo-log. Requiere que se use control de concurrencia pesimista.

- Lazy version management o _deferred update_ porque las actualizaciones se hacen al momento del commit. Las transacciones mantienen su _redo-log_ privado (en un buffer).

=== Criterios de corrección _correctness_

- Secuencialidad (Serializability):  Las transaccciones deben ser secuenciables, los resultados deben ser idénticos a si se ejecutan en una secuencia. No requiere que se ejecuten en un orden de tiempo real estricto, pueden intercambiarse el orden.

- Secuencialidad estricta: Si una transacción se completa antes que otra su ejecución secuencial debe ocurrir en el mismo orden.

- Linearizabilidad (Linearizability): La operación de lecturas y escritura de toda la transacción debe aparecer en un momento puntual.

- Instantáneas aisladas (Snapshot isolation): Es más débil que linearizabilidad, permite mayor concurrencia. Las lecturas debe ser linearizables antes que las escrituras.


Limitaciones de los bloques:
Problema del deadlock como en barreras

volatile bool flagA = false;
volatile bool flagB = false;
// Thread 1 // Thread 2
atomic {
    while (!flagA); // 1.1 flagA = true;
    flagB = true; // 1.2 while (!flagB);
}

Single-Lock Atomicity (SLA) for Atomic Blocks

Los problemas de llamadas de sistemas, E/S y transacciones externas

Transacción son una serie de pasos ejecutados por un único proceso. Deben ser secuenciables, parecen ejecutarse secuencialmente en un orden de una a la vez.

Singh developed a library of join patterns using atomic blocks in STM-Haskell [294].T

With speculative lock elision (SLE), critical sections execute speculatively with TM-like techniques being used to dynamically detect conflicts between them. If there is a conflict between speculative critical sections then one or other of the critical sections can be re-executed, or the implementation can fall back to non-speculative execution and actually acquire the lock in question. Conflicts between speculative and non-speculative critical sections can be detected by having speculative sections monitor that the locks they acquire are currently available.

<<Rajwar>>

las ejecuciones son especulativas, los cambios son tentativos, si se completa la transacción se hace el _commit_.

En software, versionID, global lock, blocking & nonblocking



.Programación con tinySMT
[source, c]
----
TM_INIT_THREAD;

for (i=0; i < max; i++) {
    TM_START(0, 1);
    c = TM_LOAD(&counter[position]);
    c++;
    TM_STORE(&counter[position], c);
    TM_COMMIT;
}

TM_EXIT_THREAD;
----


==== GCC

[source, c]
----
    for (i=0; i < max; i++) {
        __transaction_atomic {
            counter[position]++;
        }
    }
----


Transactional Execution Facility included with the
   IBM zEnterprise zEC12 processor has been added.
The libitm library has
   been modified to add a HTM fastpath that automatically uses POWER's
   HTM hardware instructions when it is executing on a HTM enabled
   processor.


=== Hardware

EXPLICITLY TRANSACTIONAL HTMS
- Optimistic Synchronization, similar al LL/SC.
- Herlihy and Moss HTM: load-transactional, store-transactional, and load-transactional-exclusive
- Oklahoma Update: Operación atómica sobre varios registros.
Advanced Synchronization Facility. Recently, the Advanced Synchronization Facility (ASF) proposal [61] from Advanced Micro Devices takes a similar approach to the explicit HTM systems discussed so far. It introduces a SPECULATE instruction to begin a transaction, along with a COMMIT instruction to mark the end. Control returns implicitly to the SPECULATE instruction if the speculative region aborts, setting the processor flags to indicate that this has occurred. Simple flattened nesting is supported; speculation continues until the outermost COMMIT occurs. ASF proposes the use of a LOCK prefix to be added to memory accesses that should be performed transactionally. In the implementation proposal, ASF proposes the use of dedicated registers, similar to Oklahoma Update, to perform a multi-word compare-and-swap-like operation.



IMPLICITLY TRANSACTIONAL HTM SYSTEMS
- Speculative Lock Elision. to roll back register state, The SLE implementation uses the store buffer to hold updates performed transactionally


- Rock HTM. Rock HTM is an implicitly transactional HTM designed for a modern processor from Sun. However, Rock HTM requires the level two (L2) cache to track all store addresses inside the transaction.


Intel:
Intel microprocessors based on the Haswell microarchitecture



==== Hardware lock elision
Hardware Lock Elision: xaquire/xrelease, usan los mismo prfijos que REPNE/REPE y sin ignorados si no se soporta.

Si falla vuelve a ejecutar sin eludir el mutex.



----
movl    $1, %eax
xchgl	mutex(%rip), %eax
...
movl    $0, %eax
----

----
movl    $1, %eax
xacquire xchgl  mutex(%rip), %eax
...
movl    $0, %eax
xrelease movl   %eax, mutex(%rip)
----


----
void lock() {
    while(exchange_n(&mutex, 1, __ATOMIC_ACQUIRE|__ATOMIC_HLE_ACQUIRE));
}

void unlock() {
     store_n(&mutex, 0, __ATOMIC_RELEASE|__ATOMIC_HLE_RELEASE);
}
----


=== Hardwate


Restricted Transactional Memory: xbegin, xend, xabort, ¿xcheck?.

IBM Power PC, Transactional Memory, tbegin, tend, tabort, tcheck

IBM S390 tbegin, tend, tabort, etnd


==== HTM

Siempre debe proveer un camino alternativo.

[source, c]
----
for (i=0; i < max; i++) {
    if (_xbegin() == _XBEGIN_STARTED) {
        if (mutex) {
            _xabort(1);
        }
        counter[position]++;
        _xend();
    } else {
        lock();
        counter[position]++;
        unlock();
    }
}
----


GCC:





https://gcc.gnu.org/onlinedocs/gcc-4.8.4/gcc/x86-specific-memory-model-extensions-for-transactional-memory.html#x86-specific-memory-model-extensions-for-transactional-memory
The i386 architecture supports additional memory ordering flags to mark lock critical sections for hardware lock elision. These must be specified in addition to an existing memory model to atomic intrinsics.


__transaction_atomic {
    count++;
}


=== Tiemps

.Tiempos de ejecución STM
[caption=""]
image::tm_software.png[align="center"]


.Tiempos de ejecución HTM Intel
[caption=""]
image::tm_hardware.png[align="center"]
