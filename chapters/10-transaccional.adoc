== 10. Memoria transaccional... en proceso



Los problemas de locks:

- Algoritmos de _spinlocks_ complejos por la dificultad de componer llamadas a múltiples objetos en unidades atómicas.

- Las primitivas atómicas solo trabajan con una palabra a la vez, resulta en algoritmos complejos y algunos temas académicamente no resueltos (como las lista de doble entrada con posibilidad de añadir o extraer por ambos extremos).

- Se usan _mutex_ (o _locks_) globales para gestionar estructuras complejas como hashing o árboles balanceados por la complicación de granularidades más pequeñas. Esto afecta negativamente al paralelismo.

- Son difíciles de gestionar efectivamente, especialmente en grandes sistemas. Lo que desea el programador es indicar cuál es la sección crítica y que el sistema se encargue de controlar la granularidad.


Los _mutex_ son pesismistas, las transacciones optimistas y tentativas.
En paralelismo no hay mecanismos de abstracción y composición. Composición es la capacidad de juntar dos entidades para forma una más compleja.



Funciones
----
StartTX()
x = LoadTX(ptr)
x += 1
StoreTX(ptr, x)
CommitTx()
----

bloques:
----
transaction {
    a = b * x
}
----

La palabra clave transaction es similar a synchronized en Java, pero mientras synchronized adquiere un _lock_ específico, atomic lo es respecto a todos los demás bloques atómicos.

Como las transacciones permiten actualizaciones a diferentes ubicaciones eliminan la necesidad de comparaciones múltiples en los spinlocks.

Las transacciones son ejecutadas especulativamente, hace cambios tentativos a objetos, si acaban sin conflictos se hace el _commit_ definitivo. Si no, se aborta. Las transacciones pueden ser anidadas, son útiles porque pueden ser abortadas sin abortar al padre.


Mover un objeto de una cola a otra de forma atómica es imposible con monitores, sin embargo es trivial con transacciones.

atomic {
    x = q0.deq();
    q1.enq(x);
}




=== Transacciones en bases de datos

Las base de datos son capaces de trabajar concurrentemente y en paralelo desde hace tiempo, ejecutan varias consultas simultáneamente cuando es posible.

La popularización de los multi cores ha hecho renacer el interés de estas técnicas. Aunque se parecen ambas tienen diferencias. Una involucra acceso a disco, la otra comunicación por red.






En corazón del sistema es la transacción, espeficica una secuencia de operaciones (una composición) como si fuese la única accediendo a la base de datos.

Las operaciones se ejecutan en paralelo pero están limitadas las interacciones de forma que los resultados no varían si se ejecutaron una después de otra o al revés. Esta propiedad se llama _serialibilidad_. Simplifca el "mundo" del programador.

Las bases de datos tienen las propiedades ACID por atomicidad, consistencia, aislamiento (_isolation_) y durabilidad.

Atomicidad significa que el conjunto de operaciones de una transacción se completan todas o ninguna. Si se _rechaza_ una ejecución no debe dejar rastros. Cuando una transacción acaba correctamente se hace el _commit_, caso contrario la transacción de _aborta_.

Consistencia significa que los datos pasan de un estado consistente a otro. Por ejemplo, se respetan los invariantes, por ejemplo que el resultado de una transferencia bancaria que generó un ingreso en una cuenta también está representado la salida, no puede aparece dinero de más en la suma de ambas.

Durabilidad es que los datos queden permanentemente almacenados en un dispositivo persistente. ¿¿¿¿No se aplica a la memoria transaccional????


=== Origenes

La memoria transaccional está en su infancia. La primera propuesta para usar la idea de transacciones fue de David Lomet en 1977 (<<Lomet>>) pero no propuso ninguna solución práctica competitiva con los mecanismos de sincronización explícitos (<<Harris>>). La idea cayó en el olvido hasta 1993. Maurice Herlihy y Eliot Moss (<<Herlihy93>>) propusieron soluciones para soporte de hardware de transacciones. Janice Stone _et al_ (<<Stone>>) propusieron operaciones atómicas _multi-palabra_ conocidas como _Oklahoma Update_



Limitaciones de los bloques:
Problema del deadlock como en barreras

volatile bool flagA = false;
volatile bool flagB = false;
// Thread 1 // Thread 2
atomic {
    while (!flagA); // 1.1 flagA = true;
    flagB = true; // 1.2 while (!flagB);
}

Single-Lock Atomicity (SLA) for Atomic Blocks

Los problemas de llamadas de sistemas, E/S y transacciones externas

Transacción son una serie de pasos ejecutados por un único proceso. Deben ser serializables, parecen ejecutarse secuencialmente en un orden de una a la vez.

Singh developed a library of join patterns using atomic blocks in STM-Haskell [294].T

With speculative lock elision (SLE), critical sections execute speculatively with TM-like techniques being used to dynamically detect conflicts between them. If there is a conflict between speculative critical sections then one or other of the critical sections can be re-executed, or the implementation can fall back to non-speculative execution and actually acquire the lock in question. Conflicts between speculative and non-speculative critical sections can be detected by having speculative sections monitor that the locks they acquire are currently available.

<<Rajwar>>

las ejecuciones son especulativas, los cambios son tentativos, si se completa la transacción se hace el _commit_.

En software, versionID, global lock, blocking & nonblocking



.Programación con tinySMT
[source, c]
----
TM_INIT_THREAD;

for (i=0; i < max; i++) {
    TM_START(0, 1);
    c = TM_LOAD(&counter[position]);
    c++;
    TM_STORE(&counter[position], c);
    TM_COMMIT;
}

TM_EXIT_THREAD;
----


==== GCC

[source, c]
----
    for (i=0; i < max; i++) {
        __transaction_atomic {
            counter[position]++;
        }
    }
----


Transactional Execution Facility included with the
   IBM zEnterprise zEC12 processor has been added.
The libitm library has
   been modified to add a HTM fastpath that automatically uses POWER's
   HTM hardware instructions when it is executing on a HTM enabled
   processor.


=== Hardware

EXPLICITLY TRANSACTIONAL HTMS
- Optimistic Synchronization, similar al LL/SC.
- Herlihy and Moss HTM: load-transactional, store-transactional, and load-transactional-exclusive
- Oklahoma Update: Operación atómica sobre varios registros.
Advanced Synchronization Facility. Recently, the Advanced Synchronization Facility (ASF) proposal [61] from Advanced Micro Devices takes a similar approach to the explicit HTM systems discussed so far. It introduces a SPECULATE instruction to begin a transaction, along with a COMMIT instruction to mark the end. Control returns implicitly to the SPECULATE instruction if the speculative region aborts, setting the processor flags to indicate that this has occurred. Simple flattened nesting is supported; speculation continues until the outermost COMMIT occurs. ASF proposes the use of a LOCK prefix to be added to memory accesses that should be performed transactionally. In the implementation proposal, ASF proposes the use of dedicated registers, similar to Oklahoma Update, to perform a multi-word compare-and-swap-like operation.



IMPLICITLY TRANSACTIONAL HTM SYSTEMS
- Speculative Lock Elision. to roll back register state, The SLE implementation uses the store buffer to hold updates performed transactionally


- Rock HTM. Rock HTM is an implicitly transactional HTM designed for a modern processor from Sun. However, Rock HTM requires the level two (L2) cache to track all store addresses inside the transaction.


Intel:
Intel microprocessors based on the Haswell microarchitecture



==== Hardware lock elision
Hardware Lock Elision: xaquire/xrelease, usan los mismo prfijos que REPNE/REPE y sin ignorados si no se soporta.

Si falla vuelve a ejecutar sin eludir el mutex.



----
movl    $1, %eax
xchgl	mutex(%rip), %eax
...
movl    $0, %eax
----

----
movl    $1, %eax
xacquire xchgl  mutex(%rip), %eax
...
movl    $0, %eax
xrelease movl   %eax, mutex(%rip)
----


----
void lock() {
    while(exchange_n(&mutex, 1, __ATOMIC_ACQUIRE|__ATOMIC_HLE_ACQUIRE));
}

void unlock() {
     store_n(&mutex, 0, __ATOMIC_RELEASE|__ATOMIC_HLE_RELEASE);
}
----


=== Hardwate


Restricted Transactional Memory: xbegin, xend, xabort, ¿xcheck?.

IBM Power PC, Transactional Memory, tbegin, tend, tabort, tcheck

IBM S390 tbegin, tend, tabort, etnd


==== HTM

Siempre debe proveer un camino alternativo.

[source, c]
----
for (i=0; i < max; i++) {
    if (_xbegin() == _XBEGIN_STARTED) {
        if (mutex) {
            _xabort(1);
        }
        counter[position]++;
        _xend();
    } else {
        lock();
        counter[position]++;
        unlock();
    }
}
----


GCC:





https://gcc.gnu.org/onlinedocs/gcc-4.8.4/gcc/x86-specific-memory-model-extensions-for-transactional-memory.html#x86-specific-memory-model-extensions-for-transactional-memory
The i386 architecture supports additional memory ordering flags to mark lock critical sections for hardware lock elision. These must be specified in addition to an existing memory model to atomic intrinsics.


__transaction_atomic {
    count++;
}


=== Tiemps

.Tiempos de ejecución STM
[caption=""]
image::tm_software.png[align="center"]


.Tiempos de ejecución HTM Intel
[caption=""]
image::tm_hardware.png[align="center"]
