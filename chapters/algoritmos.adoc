== Algoritmos de exclusión mutua

En este capítulo estudiaremos la solución al problema de la exclusión mutua para dos procesos. Empezaremos analizando los problemas de algoritmos simples hasta llegar a la primera solución, el _algoritmo de Dekker_ de 1963 footnote:[Theodorus Jozef  Dekker es un matemático holandés nacido en 1927, su algoritmo se considera el primero que solucionó problemas de procesos concurrentes.]. Luego veremos una solución equivalente pero más sencilla desarrollada por Peterson <<Peterson>> en 1981. Finalmente estudiaremos la solución para N procesos, el _algoritmo de la panaderia_ de Leslie Lamport <<Lamport>>.

Por supuesto estos algoritmos no se usan por varios motivos, uno de ellos es que no funcionan en las arquitecturas de procesadores modernos ya que hacen reordenamiento de instrucciones (_out of order execution_) para optimizar la ejecución lo que obliga a usar _barreras de memoria_ (_memory barriers_) que se explican más adelante. Tampoco se usan porque consumen mucha CPU al hacer _espera activa_ y existen otras primitivas que eliminan los problemas mencionados y que veremos a continuación: instrucciones por hardware, semáforos, monitores y paso de mensajes.

El objetivo de estudiar estos algoritmos y la evolución hasta encontrar la solución es aprender a reconocer y razonar sobre los problemas de los algoritmos concurrentes, conocer las reglas fundamentales para el diseño de los algoritmos, cómo probar que son correctos y aprender la terminología básica y su aplicación: _esperas activas_, _interbloqueos_ (_deadlocks_), _inanición_ (_starvation_), _livelocks_, etc. Este conocimiento no tiene un interés puramente académico, además de comprender cómo se implementan los mecanismos y abstracciones de más alto nivel en los diferentes lenguajes y sistemas os ayudará a detectar y razonar sobre los problemas de concurrencia y condiciones de carreras de vuestros programas y hasta de operaciones SQL en bases de datos.



=== Solución para dos procesos



<<Stallings>> propone seis requerimientos equivalentes a los anteriores pero que facilitan el análisis y validar el código.

. Debe asegurarse exclusión mutua.
. Un proceso que se interrumpe en su sección no crítica (o _resto del código_) no debe interferir a los demás procesos.
. No debe permitirse que ningún proceso espere indefinidamente en la _entrada de la sección crítica_ (es decir, libre de interbloqueo e inanición).
. Si no hay ningún proceso en la sección crítica y uno desea entrar debe poder hacerlo inmediatamente.
. No se deben hacer suposiciones de la velocidad relativa de los procesos ni del número de procesadores.
. Un proceso permanece en su sección crítica por tiempo finito (lo asumimos como cierto).


==== Primer intento

----
        turn = 0
----
----
while turn != 0:
  pass

critical_section()

turno = 1;
----


==== Segundo intento

----
        states = [False, False]
----

----
while state[1]:
	pass
states[0] = True

critical_section()

states[0] = False

----

==== Tercer intento

----
        states = [False, False]
----

----
states[0] = True
while states[1]:
	pass

critical_section()

states[0] = False

----


==== Cuarto intento

----
        states = [False, False]
        turn   = 0
----

----
states[0] = True
while states[1]:
	if turn == 1:
		states[0] = False
		states[0] = True

critical_section()

states[0] = False

----


==== Algoritmo de Dekker

----
        states = [False, False]
        turn   = 0
----

----
states[0] = True
while states[1]:
	if turn == 1:
		states[0] = False
		while turn != 0:
			pass
		states[0] = True

critical_section()

states[0] = False
----

==== Algoritmo de Peterson


----
        states = [False, False]
        turn   = 0
----

----
states[0] = True
turn = 1
while states[1] and turn == 1:
	pass:

critical_section()

states[0] = False
----


=== Solución para N procesos: algoritmo de la panaderia

----
        # N is the max number of processes
        choosing = [False, ..., False] # size N
        number   = [0, ..., 0] # size N
----

----
choosing[i] = True
number[i] = max(choosing) <1>
choosing[i] = False
for j in range(0, N):
	while choosing[j]: <2>
		pass
	while number[j] < number[i] or <3>
		(number[j] == number[i] and
			j < i):
		pass

critical_section()

number[i] = 0
----

