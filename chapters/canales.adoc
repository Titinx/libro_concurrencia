[[channels]]
== Canales

Las construcciones de programación concurrente vistas hasta ahora (algoritmos, _spinlocks_, semáforos y monitores) rquieren memoria compartida, ahora veremos otro tipo de construcción donde no se comparte memoria sino que se pasa la información mediante _mensajes_.

El concepto de canales como mecanismo de sincronización entre procesos fue introducido por Hoare en su muy influyente artículo _Communicating Sequential Processes_ (<<Hoare>>). En él definió un lenguaje formal, _CSP_, para describir la interacción entre procesos genéricos independientes -no comparten memoria- cuya única forma de comunicación y sincronización en el paso _mensajes_ a través de canales (_puertos_ en el original). La entrada de un proceso es la salida de otro proceso, ambos procesos se ejecutan en paralelo pero se sincronizarán en la entrada-salida. Definió dos operadores, `?` para indicar la entrada de un proceso y `!` para la salida.

Ejemplos:

Leer desde el proceso _XY_ y almacenarlo en el par de variables _x, y_:

    XY?(x, y)

Enviar el contenido de _x_ e _y_ al proceso _DIV_:

    DIV!(x, y)


El primer lenguaje que se desarrolló con este modelo fue Occam (1983) de David May (con la colaboración de Hoare) para INMOS, los fabricantes de los procesadores _Transputer_. Con el tiempo de diseñaron una rama de lenguajes que com este modelo Erlang (Armstrong, 1986), Newsqueak (Pike, 1988), Concurrent ML (Reppy, 1993),  Alef (Winterbottom, 1995) y Limbo (Dorward, Pike y Winterbottom, 1996). Erlang es el que más éxito ha tenido y sigue siendo muy usado para sistemas concurrentesfootnote:[La mayoría de los lenguajes modernos tienen algún tipo de soporte de canales o sincronización por mensaje, si no es una construcción sintáctica del lenguaje lo hacen vía clases o librerías].

.Erlang
****
Erlang fue diseñado en Ericcson para sus sistemas con alta disponibilidad y concurrencia. No comparte estado entre los diferentes hilos de ejecución, como _CSP_ implementa canales con los mensajes como única forma de comunicación. A diferencia de _CSP_, Erlang usa mensajes asincrónicos que se almacenan en _buffers_ denonimados _buzones_ (_mailboxes_) desde donde son recogidos por la espeficifación de patrones en el receptor (similar a los _guard commands_ de Dijkstra también parte de _CSP_). Por todas estas características se dice que Erlang sigue el modelo de _actores_.
****


Al igual que _CSP_ implementa el intercambio de mensajes sincrónicos


En 2010 Google publicó la primera versión estable del lenguaje Go,



CSP/Dijkstra guarded commands

----
Pid = spawn(fun() ->
          receive Val ->
            io:format("Message: ~s", [Val])
          end
      end).
Pid ! "Hello".
----


----
c := make(chan string)
go func() {
    fmt.Println("Message:", <- c)
}();
c <- "Hello"
----

=== Tipos

=== Sincronización

==== Con y sin buffer

=== Exclusión mutua con mensajes

==== Ejemplo en Go

=== Otros algoritmos

////
gofmt  -w -tabs=false -tabwidth=4


http://www.slideshare.net/dabeaz/an-introduction-to-python-concurrency (para ver lo de mensajes)
////
