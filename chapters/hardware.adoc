[[hardware]]
== Soluciones por hardware
Hasta ahora hemos visto soluciones al problema de la exclusión mutua sin soporte de hardware y con sólo _registros de lectura-escritura atómicos_. Hemos visto que tanto para la solución de dos procesos (Dekker y Peterson) como para _N_ procesos (Panadería) se necesita una cantidad de registros proporcional al número de procesos que han de sincronizar. Está demostrado (<<Herlihy12>>) que dichos algoritmos son óptimos en cuestión de espacio

Los algoritmos anteriores implementan _spinlocks_ pero son muy ineficientes. Además de la sobrecarga para mantene la consistencia de cache se recorren múltiples registros aunentando el consumo de CPU y la presión sobre la cache. Si habéis probado los algoritmo anteriores, en algunos procesadores puede tomar tiempos de órdenes de magnitud superiores a otros. En el caso de un único procesador el avance es tan lento que lo que tarda décimas en uno puede tomar horas en otrosfootnote:[Como pasa en la Raspberry 1.] en el caso de que exista mucha _competencia_ (o _contention_) para entrar a la sección crítica.

Obviamente desde el inicio se buscó una solución con soporte del hardware.


=== Deshabilitar interrupciones
Si el problema fundamental es el intercalado de instrucciones generado por las interrupciones al procesador ¿por qué no deshabilitarlas?. Aunque es una solución que se usa en casos muy específicos en los sistemas operativosfootnote:[Como local_irq_disable() o local_irq_enable() en Linux.] no es una solución segura: si los procesos pueden deshabilitar las interrupciones entonces pueden tomar control del sistemafootnote:[Deshabilita la cualidad de _apropiativo_ (o _preemptive_) del _scheduler_.]. Por lo tanto es una solución genérica válida para los procesos de usuario.

Aún al nivel del núcleo del sistema operativo presenta dificultades: la complicación de deshabilitar todas las interrupciones en todos los procesadores y el riesgo de perder interrupciones. Dada la dificultad de deshabilitar las interrrupciones en todos los procesadores tampoco es una solución para asegurar exclusión mutua dado que un _registro_ puede ser modificado por un procesador diferente sin que haya habido intercalación en el mismo procesador.

=== Sincronización por hardware
Por ello se buscaron otras alternativas que en general son conocidas como _primitivas de sincronización de hardware_. Son instrucciones del procesador que leen y modifican el valor de un registro sin ser interrumpidas y asegurando la coherencia de cache (introducen barreras de memoria). Hay muchas variantes de estas instrucciones, -_getAndAdd_, _testAndSet (TAS)_, _swap_, _compareAndSwap (CAS)_, etc.-, cada una con propiedades diferentes. Pero antes de estudiarlas veremos definiciones más genéricas de _registros_ que  proporcionen modelos simples y genéricos de consistencia por encima de las interrrupciones o mecanismos de consistencia de cache.

=== Tipos de registros
El término _registro_ no trata sólo de los registros del procesador, su uso es más general. Puede involucrar a zonas de memoria RAM o en términos generales a un _objeto compartido_. Aunque nos interesan los registros de hardware hay que tener en cuenta que estos son intermediarios de la memoria RAM lo que implica asegurar consistencia de cache.

A nivel de hardware los hilos se comunican leyendo y escribiendo en memoria compartida. Desde el punto de vista del hardware la comunicación se hace vía registros de lectura-escritura. Un registro de este tipo encapsula dos métodos, _read_ y _store_. O _get_ y _write_ cuando nos referimos a objetos compartidos en general y que pueden ser implementados en lenguajes de alto nivel.


==== Registros _seguros_

Los registros con las propiedades de consistencia más débiles son los _registros seguros_, su nombre es un mero accidente histórico, son muy inseguros (<<Herlihy12>>). Estos tipos de registros sólo aseguran que se retorna el último valor escrito si no hay operaciones _get_ y _write_ concurrentes, caso contrario podrá devolver cualquier valor aceptable en el rango del registro.

==== Registros regulares

Una alternativa intermedia son los _registros regulares_ donde una operación de lectura concurrente con escrituras puede retornar alguno de los valores que están siendo escritos. Se dice que estos registros sólo aseguran _consistencia por inactividad_ (_quiescent consistency_) ya que sólo aseguran retornar el mismo valor después de un período de inactividad entre el último _write_ y el siguiente _get_.

==== Registros atómicos

Los registros de procesadores modernos que usamos para la implementación de los algoritmos de exclusión mutua son _registros atómicos_, generalmente bytes únicos, enteros de varios bytes o referencias a memoria u objetos que cumplen las siguientes dos condiciones (<<Lamport2>>):

1. El método _get_ retorna el último valor escrito, si una lectura retorna un valor y no hubo otra escritura intermedia la siguiente lectura será el mismo valor.

2. Si hay varios _write_ concurrentes el valor que retornará el siguiente _get_ es uno de los valores del _write_ no un rango de posibles valores. Por ejemplo, si un _write_ concurrente es el número 0 y otro es el número 1000, el _get_ retornará 0 o 1000, ni un valor intermedio ni del rango posible que puede tomar el registro.

==== Primitivas de harware y registros Read-Modify-Write
Como hemos observado en la implementación del algoritmo de la panadería, el requerimiento de registros atómicos para solucionar los problemas de exclusión mutua crece linealmente con el número de hilos o procesos involucrados. Tiene otros problemas, son _spinlocks_ sobre muchos registros que introducen mucha presión sobre grandes zonas de la cache, por lo que son muy ineficientes. El otro problema era tener que introducir barreras de memoria para forzar la consistencia secuencial.

Por ello no es de extrañar que desde el principio se introdujen instrucciones atómicas del procesador que permitiesen implementar operaciones de sincronización de forma más sencilla y eficiente. Este tipo de operaciones pueden ser expresadas como construcciones de registros denominados genéricamente _registros Read-Modify-Write_ o _RMW_. Los registros _RMW_ son interesantes porque pueden implementarse en construcciones de lenguajes o como instrucciones de procesador, sus propiedades son similares.


[NOTE]
[[consensus]]
.Registros RMW no triviales
====

Los registros _RMW_ que proveen operaciones adicionales a la _función identidad_ se denominan _no triviales_. <<Herlihy91>> demostró que los registros no triviales tienen un _consenso_ de al menos 2 (o son de _clase 2_). Todas las instrucciones mencionadas anterioremente (a excepción de la identidad, como es obvio) implementan registros RMW no triviales.

De todas las implementaciones, _compareAndSwap_ es la más potente. <<Herlihy91>> demostró que pertenece a la clase de consenso N (o _infinito_). Este tipo de instrucciones son, en palabras de <<Herlihy12>>, _a la computación asincrónica el equivalente de las máquinas de Turing de la computación secuencial_. Afortunadamente la mayoría de procesadores implementan la instrucción _compareAndSwap_ o la similar _load-linked/store-conditional_ (o _LL/SC_, disponible en las arquitecturas Power, MIPS y ARM).

====

Hay varios tipos de intrucciones que implementan registros _RMW_:

- _get_: Retorna el valor del registro, se denomina también _función identidad_.
- _getAndSet_: Asigna un nuevo valor al registro y retorna el anterior.
- _getAndAdd_: Incrementa el valor del registro en el valor indicado y retorna el valor anterior.
- _testAndSet_: verifica el valor del registro, si es cero asigna el nuyevo valor (habitualmente 1, por ejemplo en IBM 360 el registro es binario o booleano, solo admite 0 y 1).
- _swap_: Intercambia el valor de dos registros.
- _compareAndSwap_: Compara el valor del registro con otro, si son iguales asigna un nuevo y retorna el anterior.

Los fabricantes proveen muchas operaciones diferentes, y compiladores como el GCC tienen macros que generan estas instrucciones o sus equivalentes: <<Atomics_C11>> y las antiguas <<Atomics>>.  Estudiaremos cómo implementar exclusión mutua con algunas de estas primitivas.

[IMPORTANT]
====

A partir de aquí usaremos las primitivas atómicas de las últimas versiones de GCC (<<Atomics_C11>>). Estas primitivas implementan el modelo de memoria de C11 y C\+\+11. para probar los ejemplos en C aseguraros de tener versiones nuevas del GCC, estos ejemplos fueron probados con la versión 4.9.

====


===== getAndSet
Usaremos una variable global `mutex` que estará inicializada a cero e indica que no hay procesos en la sección crítica. En la entrada de la sección crítica se almacena 1 y se verifica si el valor anterior era 0 (es decir, no había nadie en la sección crítica). Si era diferente a cero esperará hasta que lo sea.

La función `lock()` es la entrada a la sección crítica y `unlock()` la salida.

----
		mutex = 0

def lock():
	while getAndAdd(mutex, 1) != 0:
		pass

def unlock():
	mutex = 0

----

En <<getAndSet>> está el código en C implementado con el macro `__atomic_exchange_n`. A pesar de su nombre no es la instrucción _swap_ sino un equivalente para _getAndSet_.


===== getAndAdd

Se puede implementar exclusión mutua con una idea muy similar a la del algoritmo de la panadería, cada proceso obtiene un número y espera a tu turno. Sólo que esta vez la obtención del _siguiente número_ es atómica y por lo tanto no se necesita un array de números ni hacer un bucle de controles adicionales.

Usaremos dos variables, `number` para el siguiente número y `turn` para indicar a qué número le corresponde entrar a la sección crítica.


----
		number = 0
		turn = 0

def lock():
	""" current is a local variable """
	current = getAndAdd(number, 1)
	while current != turn:
		pass

def unlock():
	getAndAdd(turn, 1)

----

En <<getAndAdd>> podéis ver el código en C implementado con el macro `__atomic_fetch_add` y en Go con `atomic.AddUint32`.footnote:[Estrictamente no es getAndAdd sino addAndGet, devuelve el valor después de sumar, pero son equivalentes, sólo hay que cambiar la inicialización de la variable turn.] A diferencia de la implementación con _getAndSet_ esta implementación asegura que no se producen esperas infinitas ya que el número que _elige_ cada proceso es único y creciente, aunque hay que tener en cuenta que el valor de `number` llegará a un máximo y rotará. Los _spinlocks_ de este tipo son también llamados _Ticket lock_ y son muy usados, incluso en el núcleo de Linux, por que aseguran que no se producen esperas infinitas y que los procesos entran a la sección crítica en orden FIFO (_fairness_).



===== testAndSet

La instrucción _testAndSet_ o _TAS_ fue la instrucción usada para control de concurrencia hasta la década de 1970 cuando fue reemplazada por operaciones que permitían niveles (_clase_) de consenso más elevados. La implementación consiste de una variable entera binaria (o _booleana_) que podía tomar valores 0 y 1. La intrucción sólo recibe un argumento, la dirección de memoria. Si el valor de la dirección de memoria es 0 le asigna 1 y retorna 1 (o _true_), caso contrario retorna 0 (o _false).

----
def testAndSet(register):
	if register == 0:
		register = 1
		return 0

	return 1
----

La implementación de exclusión mutua con TAS es muy similar a _getAndSet_:

----
		mutex = 0

def lock():
	while testAndSet(mutex) == 0:
		pass

def unlock():
	mutex = 0

----

El código en C implementado con el macro `__atomic_test_and_set`: <<testAndSet>>.

=== Swap

Esta instrucción intercambia atómicamente dos posiciones de memoria, usualmente enteros de 32 o 64 bitsfootnote:[No todas las arquitecturas la tienen, en Intel es XCHG para enteros de 32 bits. Esta función estaba implementada en el antiguo <<Atomics>> con el confuso nombre de `__sync_lock_test_and_set` pero realmemte ejecuta la instrucción XCHG y devuelve el valor anterior de la primer variable. Su algoritmo es igual al genérico pero devuelve el valor previo de la primer variable, en este sentido es equivalente a _getAndSet_]. El algoritmo de la instrucción es tan sencillo como parece:

----
def swap(register1, register2):
	tmp = register1
	register1 = register2
	register2 = tmp
----

El algoritmo de exclusión mutua con _swap_:

----
		mutex = 0

def lock():
	local = 1
	while local != 0:
		swap(mutex, local)

def unlock():
	mutex = 0
----

La implementación con el macro `__atomic_exchange` de las últimas versiones de GCC: <<counter_swap_c>>. En Go se pueden usar las funciones atómicas implementadas en el paquete `sync/atomic`, por ejemplo con `atomic.SwapInt32`: <<gocounter_swap_go>>footnote:[Esta función no estaba disponible en Go para ARM hasta 2013, si la pruebas en una Raspberry asegúrate de tener una versión de Go moderna.].

=== Compare&Swap

Esta instrucción, o _CAS_, es la más comúnfootnote:[Es la que se usa en la arquitectura Intel/AMD.] y la que provee el mayor _nivel de consenso_ (ver nota <<consensus>>)footnote:[Aunque sufre el _problema ABA_.]. La instrucción trabaja con tres valores:

. Registro: que se comparará y asignará un nuevo valor si corresponde.
. Nuevo valor: el valor que se asignará al registro.
. Valor a comparar: si el valor del registro es igual a este valor entonces se asigna al registro, caso contrario se copia el valor del registro al valor a comparar.


En la versión modernafootnote:[En los antiguos <<atomics>> las instrucciones equivalentes `__sync_bool_compare_and_swap` y `__sync_val_compare_and_swap` respectivamente. La diferencia fundamental es que no se modifica el registro del valor a comparar.] de macros atómicos las dos versiones son `__atomic_compare_exchange_n` y `__atomic_compare_exchange_n`, ambas retornan un booleano si se pudo hacer el cambio, lo único que cambian es la forma de los parámetros (en el último caso son todos punteros). El algoritmo de estas instrucciones es:

----
def compareAndSwap(register, expected, desired):
	if registro == expected:
		registro = desired
		return True
	else:
		expected = register
		return False
----



La implementación de exclusión mutua en C (<<counter_compare_and_swap_c>>)
es sencilla, necesitamos una variable local porque hay que pasar un puntero y ambas instrucciones copiarán el valor de mutex a la posición indicada por el puntero:

----
		mutex = 0

def lock():
	local = 0
	while not compareAndSwap(mutex, local, 1):
		local = 0

def unlock():
	mutex = 0
----

La instrucción `CompareAndSwapInt32` en Go ()<<gocounter_compare_and_swap_go>>) es algo diferente y más similar al antiguo macro de GCC. Los argumentos del valor _esperado_ y el _nuevo_ no se pasan por puntero sino por valor. La función en Go queda de la siguiente forma:

[source,go]
----
func lock() {
	for ! atomic.CompareAndSwapInt32(&mutex, 0, 1) {}
}
----




Reader-writer: https://jfdube.wordpress.com/2014/01/03/implementing-a-recursive-read-write-spinlock/
https://jfdube.wordpress.com/2014/01/12/optimizing-the-recursive-read-write-spinlock/


==== El problema ABA

_CAS_ tiene un problema conocido, el _problema ABA_, aunque este no se presenta en casos sencillos como el de exclusión mutua sino en casos de intercalado donde uno de los procesos pudo modificar el registro y volver a poner el mismo valor que antes antes que el otro se vuelva a ejecutar. Para explicar mejor el problema analizaremos un caso real.

Tenemos implementada una pila de estructuras _node_, con las funciones _push_ y _pop_ para agregar y quitar elementos de la pila. _push_ recibe como argumentos el puntero a la variable cabecera de la pilafootnote:[Es decir, al primer nodo.] y el puntero al nodo a añadir. _pop_ sólo recibe el puntero a la cabeza de la pila y devuelve el puntero al primer elemento de la pila (o NULL sin no hay ninguno). A continuación el código en C _simplificado_ de ambas funciones.

[source, c]
----
void push(struct node **head, struct node *e) {
	e->next = *head; <1>
	while (! CAS(head, &e->next, &e); <2>
}


struct node *pop(struct node **head) {
	struct node *result, *orig;

	orig = *head; <3>
	if (! orig) {
		return NULL; <4>
	}
	while (! CAS(head, &orig, &orig->next); <5>

	return orig; <6>
}
----
<1> _push_: El nodo siguiente al nodo a insertar será el apuntado por la cabecera.
<2> _push_: Si la cabecera no fue modificada se hará el cambio y ahora apuntará al nuevo nodo `e`. Si por el contrario `head` fue modificada, el nuevo valor de `head` se copia a `e->next` (ahora apuntará al elemento nuevo que apuntaba `head`) y se volverá a intentar. Cuando se haya podido hacer el _swap_ `head` apuntará correctamente a `e` y `e->next` al elemento que estaba antes.
<3> _pop_: Se hace una copia de la cabecera.
<4> _pop_: Si es NULL la pila está vacía y retorna el mismo valor.
<5> _pop_: Si por el contrario la cabecera apuntaba a un nodo y ésta no fue modificada se hará el cambio y la cebecera apuntará al siguiente nodo. Si por el contrario fue modificada se hará una copia del último valor a `orig` y se volverá a intentar.
<6> _pop_: Se retorna el puntero al nodo que antes apuntaba la cabecera.

Este algoritmo funciona sin problemas, de hecho es un algoritmo correcto para gestionar una pila concurrente... solo si es imposible eliminar un nodo y volver a insertar otro nuevo con la misma dirección de memoria. Con _CAS_ es imposible saber si otro proceso ha modificado y vuelto a poner el mismo valor del que hicimos una copia. Supongamos que tenemos una pila con tres nodos que comienzan en la direcciones 10, 20 y 30:

    head -> [10] -> [20] -> [30]

El proceso _P1_ que acaba de ejecutar `orig = *head;` dentro de _pop_ y es interrumpido. Otro procesos eliminan dos elementos de la pila:

    head -> [30]

Y luego se inserta un nuevo nodo con una dirección usada previamente:

    head -> [10] -> [30]

Cuando _P1_ continue su ejecución el CAS hará el cambio ya que la direccion es también `10`. El problema es que era una copia antigua que apuntaba antes a `[20]` por lo que dejará la cabecera apuntando a un nodo que ya no existe y los siguientes habrá quedado _descolgados_ de la pila:

    head -> ¿20?    [30]

Este caso es muy habitual si usamos `malloc` para cada nuevo nodo que insertamos y luego el `free` cuando lo eliminamos de la listafootnote:[Las implementaciones de `malloc` suelen reusar las direcciones de los elementos que acaban de ser liberados.]. En <<stack_cas_malloc_c>> está este código, si lo ejecutáis veréis que la mayoría de las veces da un _Segmentation Fault_ debido a que se intentó acceder a un nodo ya _liberado_ (el casi de [20] en el ejemplo) y otras veces errores del tipo _double free or corruption (fasttop)_ por liberar dos veces la misma memoria:

Algunas implementaciones de `malloc` no retornan las direcciones usadas recientemente (como la Debian de Raspberry) por lo que quizás no observes el problema. Podemos forzar al reuso de direcciones recientes mediante una segunda pila. En vez de liberar la memoria de los nodos con el `free` los insertamos en una segunda lista `free_nodes`. El código <<stack_cas_freelist_c>> ejecuta repetidamente el siguiente código:

[source, c]
----
e = pop(&free_nodes);
if (! e) {
	e = malloc(sizeof(struct node)); <1>
}
e->data.tid = tid;
e->data.c = i;
push(&head, e); <2>
e = pop(&head); <3>
if (e) {
	push(&free_nodes, e); <4>
}
----
<1> La lista es libres estaba vacía, se solicita memoria.
<2> Se agrega el elemento a la pila de `head`.
<3> Se elimina un elemento de la pila de `head`
<4> Si no es NULL se agrega el elemento a la pila de libres.

===== Compare&Swap etiquetado
La solución para el problema ABA es usar bits adicionales para identificar una _transacción_. Para ello algunas arquitecturas introdujeron instrucciones CAS que permiten la verificación e intercambio de más de una palabra, como el casi de Intel con la instrucción `cmpxchg8b` y `cmpxchg16b` que permite trabajar con 64 bits o 128 bits. En vez de sólo comparar punteros se pueden hacer también comparaciones con estructuras mayores. En nuestro caso necesitamos hacerlo

[source, c]
----
struct node_head {
	struct node *node; <1>
	uintptr_t aba; <2>
};

struct node_head stack_head; <3>
struct node_head free_nodes;

----
<1> El puntero al nodo que contiene los datos.
<2> Será usada como etiqueta, un contador que se incrementará en cada _transacción_. Es un entero del mismo tamaño que los punteros (32 o 64 bits según la arquitectura),
<3> Los punteros a las pilas no serán un simple puntero sino la estructura con el puntero y la etiqueta.

----
void push(struct node_head *head, struct node *e) {
	struct node_head orig, next;

	__atomic_load(head, &orig);
	do {
		next.aba = orig.aba + 1;
		next.node = e;
		e->next = orig.node;
	} while (! CAS(head, &orig, &next);
}

-----



(http://nullprogram.com/blog/2014/09/02/ https://github.com/skeeto/lstack)
Common Pitfalls in Writing Lock-Free Algorithms http://blog.memsql.com/common-pitfalls-in-writing-lock-free-algorithms/

Toward generic atomic operations/The C11 memory model http://lwn.net/Articles/509102/

Ticket Spinlocks: http://lwn.net/Articles/267968/

MCSLocks http://lwn.net/Articles/590243/

Improving ticket spinlocks  http://lwn.net/Articles/531254/


MCS Spinlocks

[[mcs_queue]]
.Cola MCS
image::mcs.png[width=400, align="center"]
