[[monitors]]
== Monitores

Los monitores evolucionaron a partir de ideas y discusiones entre Dijkstra, Brinch Hansen, Ole-Johan Dahl y C.A.R. Hoare (<<Brinch>>) como una forma de estructurar a los sistemas operativos todavía usando lenguajes de alto nivelfootnote:[De hecho le llamaron _monitor_ porque así es como se llamaba en la década de 1950 y 1960 a los antecesores de los modernos sistemas operativos.]. En 1973 fueron formalizados por Hoare (<<Hoare1>>) en su notación más conocida. La idea consistía en que el sistema operativo es un conjunto de módulos, _schedulers_, que asignan recursos compartidos para diversos procesos. Llamaban _monitor_ al conjunto de procedimientos y datos que requería cada _scheduler_.

Cada monitor debía asegurar la exclusión mutua de la ejecución de sus procedimientos y sus datos solo debían poder ser accedidos o modificados por estos procedimientos. Per Brinch Hansen diseñó y desarrolló _Concurrent Pascal_ basado en Pascal y con ideas de Modula67, fue el primer _lenguaje concurrente_, sirvió para el desarrollo de varios sistemas operativos experimentales y sus ideas se implementaron en otros lenguajes, Modula, Concurrent C, Mesa, ADA... y hasta en Java, que incluye monitores como construcción nativa del lenguajefootnote:[Lo veremos en este capítulo, es la combinación de los métodos y bloques `synchronized` con las funciones `wait()`, `notify()` y `notifyAll()`.].

En la propuesta original un monitor se declaraba de una forma similar a la siguientefootnote:[La especificación original de Hoare fue en Pascal, en la bibliografía posterior se empezó a usar una notación sin la sobrecarga de tantos `BEGIN` y `END`, es la que respeto a lo largo de este capítulo.]:

----
monitor Counter
    integer counter = 0

    procedure add
        counter = counter + 1
----

El monitor tiene una variable `counter` y el procedimiento `increment`, la variable es accesible sólo por este procedimiento. Ningún procedimiento se ejecutará si otro del mismo monitor se está ejecutando, es decir, se asegura exclusión mutua entre llamadas a procedimiento lo que automáticamente resuelve el problema de la exclusión mutua para las variables del monitor.

=== Monitores en Java
La estructura de monitores que encapsula variables y procedimientos es similar a la programación orientada a objetos, es una de las razones por la que Java implementa monitores como construcción sintáctica del lenguaje. No hay una construcción específica para definir monitores, pero cada objeto en Java tiene asociado un _mutex_ que se puede usar para forzar la exclusión mutua de la ejecución de un bloque de código indicando que es `synchronized` respecto a dicho objeto, como en el siguiente ejemplo (<<monitors_counter_object_java, código completo>>):


[source, java]
----
    Object lock = new Object();
...
    for (int i =0; i < max; i++) {
        synchronized (lock) {
            counter += 1;
        }
    }
----

Java agrega automáticamente las operaciones de _wait_ y _signal_ sobre mutex asociado al objecto `lock` a la entrada y salida del bloque. La opción más común es definiendo un método `synchronized` como en el siguiente ejemplo (<<monitors_counter_method_java, código completo>>):

[source, java]
----
...
    synchronized void add() {
        counter++;
    }
...
    for (int i =0; i < max; i++) {
        add();
    }
----

En este caso el _mutex_ está asociado a la propia instancia, el objeto `this`. La especificación `synchronized` especifica que el hilo debe obtener el _lock_ para ejecutar el método o bloque. Las llamadas a otros métodos retienen el _lock_ hasta que se haya salido del método _synchronized_, también se pueden llamar a otros métodos _synchronized_, la exclusión mutua se asegurará hasta que se haya salido del primero (es decir, es re-entrante).

****
Una clase cuyos métodos públicos están todos declarados como _synchronized_ de denomina _monitor Java_, aunque es solo una convención, no hay obligación sintáctica de hacerlo así.
****

Un error habitual al programar monitores en Java es la confusión sobre el _mutex_ y su objeto relacionado. Un método de instancia `synchronized` solo asegura la exlusión mutua de ese método sobre la misma instancia. Si hay varias instancias cada una ejecuta sus métodos independientemente de las demás. Esto significa que no se asegura exclusión mutua si hay varias instancias que modifican concurrentemente una variable estática desde un método de instancia `synchronized`. Para estos casos hay que definir explícitamente un objeto, o hacerlo desde un método `synchronized` de clase.


=== Variables de condición

La exclusión mutua no basta para la sincronización, se añaden dos operaciones, _wait_ y _signal_  que como los semáforos permiten bloquear y desbloquear procesos cuando se cumple alguna condición (opcionalmente _broadcast_ para despertar a todos los procesos). Por ejemplo bloquear a los productores si el _buffer_ está lleno y desbloquearlos cuando hay nuevamente espacio. Las dos operaciones se implementan de distintas formas:

1. Sobre unas variables explícitas denominadas _variables de condición_, donde queda a cargo del programa la verificación de condiciones y hacer los _wait_ y _signal_ sobre las variables de condición adecuadas. Estas variables no almacenan ningún valor, solo se usan como _recipientes_ de las dos operaciones. El _signal_ sobre una variable en particular desbloquea a un proceso en esa variable, si no hay ninguno no tiene ningún efecto.

2. El bloqueo automático sobre expresiones lógicas, queda a cargo de la implementación de monitores el desbloqueo de los procesos cuando la expresión se hace verdadera.

3. Operaciones genéricas _wait_ y _signal_ no ligadas a ninguna variable, por lo que cada proceso bloqueado debe verificar una variable de estado para detectar si le corresponde continuar la ejecución. Como los de primer tipo, si no hay ningún proceso bloqueado por un _wait_ el _signal_ no tiene efecto.

En el primer tipo están los monitores tradicionales (también las variables de condición en POSIX Threads), en el segundo los conocidos como _objetos protegidos_, el tercero es la implementación de monitores en Java (la operación _wait_ es el el método `wait()`, _signal_ es `notify()` y _broadcast_ es `notifyAll`).

Un monitor se suele representar gráficamente de la siguiente forma:

[[monitors_image]]
.Monitores
image::monitors.png[align="center"]


Por la exclusión mutua solo un proceso puede estar _dentro_ del monitor. Los métodos del monitor pueden bloquearse en variables de condición, al hacerlo tienen que liberar temporalmente el _lock_ para que otros procesos puedan entrar. Estos procesos se representan en _salas internas_, bloqueados esperando a que otro proceso señalice a su respectiva variable de condición. Cuando un proceso que está dentro del monitor señaliza (_S_, por _signaler_) una variable de condición donde hay varios procesos esperando (_W_ por _waiting_) además de los procesos que están esperando para entrar (_E_ por _entry_), ¿cuál de ellos continúa la ejecución.

=== Prioridades

Hay varias opciones:

1. El proceso que estaba bloqueado en la variable de condición se de reanudar inmediatamente, a esta condición se la llama _requerimiento de reanudación inmediata_ (o _IRR_ de _Immediate Resumption Requeriment_), es característica de los monitores tradicionales cuya especificación es *_E < S < W_*. Los procesos bloqueados en las variables de condición son los de mayor prioridad, el proceso que señaliza se bloquea inmediatamente para que se ejecute un proceso esperando, los que están esperando en la entrada son los de menor prioridad.

2. El proceso que señaliza sale del monitor, luego el que estaba esperando en la variable de condicón y finalmente los que esperan entrar al monitor. Esta especificación es *_E < W < S_*.

3. Los procesos que están esperando para entrar tienen la misma prioridad que los bloqueados en la dentro del monitor, *_E = W < S_*. Esta es la especificación para monitores en Java, los proceso desbloqueados por el `notify()` o `notifyAll()` van a la misma cola que los procesos en espera para entrar al monitor.


[[monitors_java_image]]
.Monitores en Javafootnote:[Imagen Wikimedia de Theodore Norvell, https://commons.wikimedia.org/wiki/File:Monitor_(synchronization)-Java.png], _E = W < S_
image::monitor_java.png[height="350", align="center"]



=== Simulación de semáforos

Hoare demostró en <<Hoare1>> que los monitores son equivalentes a los semáforos y que cualquier de ellos se puede implementar con el otro. La simulación de semáforos con monitores es un buen ejemplo del uso de estos últimos. Se necesita una variable entera para el valor del semáforo (`value`) y una variable de condición (`notZero`) para bloquear a los procesos en la operación `wait()` si el semáforo es igual a cero. El siguiente es el algoritmo con monitores tradicionales:

----
monitor Semaphore
    integer value = k
    condition notZero

    operation wait
        if value == 0
            waitC(notZero)
        value = value - 1

    operation signal
        value = value + 1
        signalC(notZero)
----

Este algoritmo es correcto pero tiene un problema, requiere la _reanudación inmediata_ (es decir _E < S < W_). Cuando un proceso ejecuta el `signal()` el proceso debe ejecutar inmediatamente para evitar que el valor del semáforo se modifique por otro proceso, por ejemplo uno que esté bloqueado esperando a entrar para ejecutar `wait()` (como puede ocurrir en Java ya que la prioridad de ambos es la misma, _E = W_) o el mismo proceso que hizo el `signal()` y luego hace otro `wait()`. En ambos casos habría el valor del semáforo valdría menor que cero.

Si el monitor no asegura _E < S < W_ hay que volver a verificar si las condición se mantiene después de despertarse del `wait()`, en este caso es verificar si el semáforo sigue siendo distinto a cero. En  `wait()` hay que cambiar el `if` por un `while`:

----
    operation wait
        while value == 0
            waitC(notZero)
        value = value - 1
----

La _reanudación inmediata_ simplifica los algoritmos pero también genera retrasos innecesarios en los procesos que señalizan. Cuando no se cuenta con esta propiedad el patrón habitual es usar `while` en vez de `if` para verificar si se cumplen las condiciones para volver a entrar al monitor. Este algoritmo puede ser directamente traducido a Java, se necesita la misma variable entera `value` y los métodos _synchronized_ `wait()` y `signal()` de los semáforos (en este caso reemplazados por `p()` y `v()` para no confundir el _wait_ de semáforos con el del método de bloqueo dentro del monitor de Java):


[source, java]
----
class Semaphore {
    int value;

    public Semaphore(int v) {
        value = v;
    }

    synchronized void p() {
        while (value == 0) {
            wait();
        }
        value--;
    }

    synchronized void v() {
        value++;
        notify();
    }
}
----

<<monitors_semaphore_java, CounterSemaphore.java>> es el código completo del contador usando la clase anterior para simular semáforos, muy similar y equivalente al <<sem_counter_java, ejemplo>> usando la clase `Semaphore` de `java.util.concurrent` que vimos en el capítulo <<semaphores>>. Si comparamos los tiempos de CPU de ambas implementaciones vemos que éste con monitores es mucho más eficiente que la implementación de las librerías de concurrencia de Javafootnote:[Hay que tener en cuenta que se hacen menos verificaciones, aún así la diferencia es enorme.].

----
$ time java semaphores/CounterSemaphore
real    0m34.974s
user    0m23.079s
sys     0m21.518s

$ time java monitors/CounterSemaphore
real    0m2.603s
user    0m3.325s
sys     0m1.148s
----

==== Variables condicionales de POSIX Threads
Los monitores no son unicamente una construcción sintáctica de lenguajes de programación, también es una forma de estructurar los programas. Se pueden implementar los mismos _algoritmos de monitores_ si se se puede asegurar exlcusión mutua entre las funciones que son parte del monitor y se cuenta con variables de condición. Las librerías POSIX Threads proveen ambas, ya hemos visto el uso de _mutex_, también ofrecen variables de condición idénticas a las diseñadas para monitores.

POSIX Threads ofrece las dos operaciones básicas sobre variables de condición: _wait_ (`pthread_cond_wait`) y _signal_ (`pthread_cond_signal`) y una tercera, la operación _broadcast_ (`pthread_cond_broadcast`) para despertar a todos los procesos bloqueados (similar a `notifyAll` de Java). Para implementar semáforos con el _método_ de monitores necesitamos las siguientes variables:


[source, c]
----
pthread_mutex_t mutex;
pthread_cond_t notZero;
int value = 1;
----


Usaremos `mutex` para controlar la exclusión mutua entre las dos operaciones (`p()` y `v()`), la variable de condición `notZero` y `value` para el valor del semáforo. Salvo las llamadas explícitas a _lock_ y _unlock_ al inicio y fin de cada función respectivamente, el resto del código es idéntico a la implementación de semáforos con monitores tradicionales. El código simplificadofootnote:[Para que no superen los márgenes no puse el código de inicialización del `mutex` y `notZero` y abrevié las llamadas `pthread_*`.] (<<monitors_semaphore_c, código completo>>):

[source, c]
----
void p() {
    mutex_lock(&mutex);

    while (value == 0) {
        cond_wait(&notZero, &mutex);
    }
    value--;

    mutex_unlock(&mutex);
}

void v() {
    mutex_lock(&mutex);

    value++;
    cond_signal(&notZero);

    mutex_unlock(&mutex);
}
----

En la operación _wait_ (`pthread_cond_wait(&notZero, &mutex)`) además de la variable de condición se envía como argumento el mismo `mutex` que se usa para las funciones para cumplir con los requisitos del monitor:

- El _mutex_ es liberado al bloquearse el proceso para que otro pueda entrar al monitor.

- El _mutex_ vuelve a adquirirse en cuánto el proceso es despertado por un _signal_ para que se asegure la exclusión mutua en el monitor. El proceso despertado no podrá continuar hasta que el que señalizó haya hecho el _unlock_ al final de su función. Además compite en la entrada con los demás procesos que estén en la cola del _mutex_, las prioridades son idénticas a las de Java: _E = W < S_.

=== Algoritmos de sincronización

En el capítulo <<semaphores>> hemos visto los algoritmos de sincronización más estudiados, nadie pretende resolver todos los problemas con dichos algoritmos o que se deban reprogramar cada vez (la mayoría de ellos ya están disponibles como librerías). Se los estudia porque son modelos de las diferentes tipos de problemas que nos podemos encontrar, vale la pena conocer los principios detrás de las librerías de alto nivel y nos proporcionan una mejor perspectiva del porqué se han diseñado de una forma u otra. Es complicado aprender a reconocer y resolver los problemas de concurrencia y sincronización, analizar los soluciones ayudan mucho al proceso.

Een este capítulo -y los siguientes- haremos lo mismo, estudiaremos los algoritmos para resolver los mismos casos que con semáforos. La buena noticia es que los problemas (barreras, productor-consumidor, lectores-escritores, etc.) ya nos son conocidos por lo que no habrá que repetir la presentación de cada uno de ellos.

==== Barreras

El algoritmo de barreras con monitores es mucho más sencillo que con semáforos. En Java sólo hace falta un contador (`arrived`) inicialmente en cero. Cuando cada proceso ejecuta `barrier()` se incrementa el contador, si todavía no es el último se bloquea con `wait()`. Si es el último proceso que faltaba por llegar pone a cero el contador y despierta a todos los procesos con un _broadcast_: `notifyAll()` (<<monitors_barrier_java, código completo>>).

[source, java]
----
synchronized void barrier(int n) {
    arrived++;
    if (arrived == n) {
        arrived = 0;
        notifyAll();
    } else {
        wait();
    }
}
----

El proceso que hace el `notifyAll()` es siempre el último proceso que faltaba llegar a la barrera, no hay interferencia ni ningún proceso puede adelantarse. Ningún otro proceso podrá entrar al monitor hasta que el último haya salido, el contador `arrived` ya valdrá cero y comenzará la cuenta para la siguiente fase. Aunque el monitor del lenguaje tenga una prioridad diferente a _E = W < S_, por ejemplo de reanudación inmediata (_E < S < W_), el valor de `arrived` ya es cero porque fue asignado antes del _signal_.

A diferencia del algoritmo con monitores tradicionales, en Java no se usan variables condicionales porque `wait()`, `notify()` y `notifyAll()` son genéricos para cada instancia (equivalente a tener una única variable de condición implícita para cada una). Así como existen las variables condicionales en POSIX Threads, otros lenguajes proveen las mismas funcionalidadesfootnote:[En Java también se pueden usar variables condicionales asociadas a un _lock_, se implementa en la clase `Lock` de `java.util.concurrent.locks`. De una instancia de `Lock` se pueden obtener las variables de condición necesarias, por ejemplo: `lock.newCondition()`].

En Python se puede usar un objeto de `threading.Condition` asociado con el _mutex_ que se usa para la exclusión mutua en las funciones del monitor. Además del contador `arrived` se usa `mutex` y la variable de condición `allArrived` sobre la que se señalizará cuando todos los procesos hayan llegado:


[source, python]
----
mutex = threading.Lock()
allArrived = threading.Condition(mutex)
arrived = 0
----

El código simplificado de la función `barrier()` (<<monitors_barrier_py, código completo>>):


[source, python]
----
def barrier(n):
    with mutex:
        arrived += 1

        if arrived == n:
            arrived = 0
            allArrived.notify_all()
        else:
            allArrived.wait()
----

La razón fundamental de la simplicidad del algoritmo de barreras es el _broadcast_ que desbloquea a todos los procesos en una única operación. Si no estuviese disponible el algoritmo sería maś complejo, hay que despertar a los procesos individualmente y asegurar que uno que superó la barrera no vuelva a ejecutarla e interfiera y se adelante a los que todavía están por desbloquearse de la fase anterior (tal como se <<alg_barriers, hace con semáforos>>).

==== Productores-consumidores

El algoritmo de productores-consumidores con _buffer_ finito se puede implementar con dos variables de condición (<<monitors_producer_consumer_py, código completo en Python>>), una para bloquear los productores cuando el _buffer_ está lleno (`notFull`) y otra para bloquear a los consumidores (`notEmpty`) cuando no hay elementos en el _buffer_.

La lógica del productor es sencilla, mientras el _buffer_ está está lleno se bloquea en `notFull`, después de agregar un elemento hace un _signal_ a `notEmpty` para que se despierte un consumidor si es que hay alguno esperando.

[source, python]
----
def append(self, data):
    with mutex:
        while len(buffer) == buffer.maxlen:
            notFull.wait()
        buffer.append(data)
        notEmpty.notify()
----

De forma similar el consumidor se bloquea si el _buffer_ está vacío y luego de obtener un elemento señaliza `notFull` por si hay productores bloqueados.

[source, python]
----
def take(self):
    with mutex:
        while not buffer:
            notEmpty.wait()
        data = buffer.popleft()
        notFull.notify()
        return data
----

El algoritmo es correcto porque asegura que el productor no puede avanzar si no hay espacio en el _buffer_ ni los consumidores si no hay elementos: mientras se hace la verificación del estado del _buffer_ ningún otro proceso puede agregar o quitar elementos por la exclusión mutua entre las funciones del monitor.


En los monitores nativos de Java no se pueden usar diferentes variables de condición pero el algoritmo es casi idéntico (<<monitors_producer_consumer_java, código completo>>):


[source, java]
----
synchronized int take() {
    while (buffer.isEmpty()) {
        wait();
    }

    data = buffer.remove();
    notifyAll();
    return data;
}

synchronized void append(Integer data) {
    while (buffer.size() == size) {
        wait();
    }
    buffer.add(data);
    notifyAll();
}
----

Al no poder esperar o señalizar variables independientes los productores y consumidores comparten la misma cola y no de puede discriminar por uno u otro. Por lo tanto ambos deben hacer un `notifyAll()` para que todos los bloqueados verifiquen si pueden continuar. Dado que se verifica la condición la condición dentro de un `while` el algoritmo también es correcto pero es más ineficiente. Cuando un productor o consumidor hace el `notifyAll()` se despiertan todos los productores y consumidores que hayan hecho en _wait_ aunque solo uno de ellos podrá salir del bucle y añadir o quitar un elemento.


==== Lectores-escritores

Se usan dos variables de condición, `canRead` para notificar a los lectores y `canWrite` para los escritores. Además dos variables, `readers` para llevar la cuenta del número de lectores en la sección crítica y la booleana `writing` para indicar si hay un escritor está en la sección crítica (<<monitors_rw_lock_py, código completo>>).

Si hay un escritor en la sección crítica los lectores se esperarán en la variable `canRead` hasta que el escritor le señalize para que vuelvan a comprobar si pueden entrar. Si puden hacerlo incrementan el número de lectores y señalizan a `canRead` para que si hay lectores bloqueados puedan continuar.

[source, python]
----
def reader_lock():
    with mutex:
        while writing:
            canRead.wait()  <1>
        readers += 1
        canRead.notify()    <2>
----
<1> Espera si hay escritores.
<2> Para que puedan entrar otros lectores.

A la salida los lectores verifican si ya no quedan otros lectores, si es así señalizan para que puedan entrar los escritores que están bloqueados.

[source, python]
----
def reader_unlock():
    with mutex:
        readers -= 1
        if not readers:
            canWrite.notify()   <1>
----
<1> Si es el último lector desbloquea a loes escritores que estén esperando.

Los escritores se bloquean en la variable `canWrite` si hay otros lectores o escritor, cuando pueden entrar ponen `writing` en `True` para bloquear a los siguientes lectores y escritores.

[source, python]
----
def writer_lock():
    with mutex:
        while writing or readers:
            canWrite.wait()     <1>
        writing = True
----
<1> Espera si hay lectores o escritores.


Cuando el escritor sale señaliza a lectores o escritores, cualquiera de ellos puede entrar.

[source, python]
----
def writer_unlock():
    with mutex:
        writing = False
        canRead.notify()  <1>
        canWrite.notify() <1>
----
<1> Señaliza a lectores y a escritores.

La última parte -la señalización a ambas variables de condición- puede cambiarse para dar  prioridad a lectores o escritores, una forma es verificar la cola de bloqueados en cada variable de condición. Si se quiere dar prioridad a los lectores se verifica `canRead`, si tiene proceso bloqueados se señaliza sólo a ella. Lo mismo puede hacerse para dar prioridad a los escritores.

Aún con estos cambios este algoritmo puede provocar la inanición de escritores si no dejan de entrar nuevos lectores mientras hay otros en la sección crítica, se puede solucionar fácilmente verificando si hay algún escritor bloqueado en `canWrite`:footnote:[Cuando se trabaja con monitores y variables de condición es relativamente sencillo agregar nuevas condiciones.]

[source, python]
----
def reader_lock():
    with mutex:
        while writing or not empty(canWrite):
            canRead.wait()
        readers += 1
        canRead.notify()
----


En Java no podemos usar dos variables de condición por lo que hay que recurrir al `notifyAll()` para desbloquear a lectores y escritores. El código es algo más ineficiente pero el algoritmo queda muy sencillo (<<monitors_rw_java, código completo>>).

Solo hacen falta dos variables, el contador de lectores (`readers`) y una booleana que indicará si hay un escritor en la sección crítica (`writing`). Los lectores solo se bloquean si hay un escritor, cuando entran hacen el `notifyAll()` para que puedan entrar otros lectores que se hayan bloqueado en el `wait()` (también despertará a los escritores que volverán a bloquearse inmediatamente).

[source, java]
----
synchronized void readerLock() {
    while (writing) {
        wait();
    }
    readers++;
    notifyAll();
}
----

Si el lector que sale es el último debe hacer el `notifyAll()` para que puedan entrar los escritores bloqueados.

[source, java]
----
synchronized void readerUnlock() {
    readers--;
    if (readers == 0) {
        notifyAll();
    }
}
----

Los escritores quedan bloqueados si hay otro escritor o lectores en la sección crítica.

[source, java]
----
synchronized void writerLock() {
    while (writing || readers != 0) {
        wait();
    }
    writing = true;
}
----

Cuando el escritor señaliza a todos para que puedan entrar los siguientes lectores y escritores.

[source, java]
----
synchronized void writerUnlock() {
    writing = false;
    notifyAll();

}
----

No se puede decidir ni conocer a priori si entrarán los lectores o un escritor, depende de quién pueda entrar primero al monitor. Al igual que el anterior este algoritmo da prioridad a los lectores. Si se desea que los escritores tengan prioridad se puede agregar un contador de número de escritores que están esperando y hacer que los lectores se bloqueen en la entrada si este contador es mayor que cero, por ejemplo:

[source, java]
----
synchronized void readerLock() {
    while (writing || waiting > 0) {
        wait();
    }
    readers++;
    notifyAll();
}
----


==== Filósofos cenando

////
Poner lectores-escritores
Agregar FUTEX con variables de condición de
http://locklessinc.com/articles/futex_cheat_sheet/
////
